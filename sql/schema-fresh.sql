-- =============================================================
-- ESQUEMA FRESCO TLC (Construcción desde cero)
-- =============================================================
-- Referencia base: sql/schema.sql
-- Ajustes clave:
--  - Sistema de IDs seguros en órdenes:
--      * id BIGINT (PK, identity)
--      * supabase_seq_id BIGINT (secuencial interno único)
--      * client_tracking_id TEXT (32 hex aleatorio, único)
--  - RPC: accept_order(order_id BIGINT)
--  - (Opcional) RPC: get_order_by_tracking(tracking_id TEXT) para lectura pública por código
--  - Políticas RLS alineadas con schema.sql
-- =============================================================

BEGIN;

-- --------------------------------------------------------------
-- 1. EXTENSIONES Y SECUENCIAS
-- --------------------------------------------------------------
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Secuencia para supabase_seq_id (decoupled del PK por flexibilidad futura)
CREATE SEQUENCE IF NOT EXISTS public.orders_supabase_seq_id_seq
  START WITH 1 INCREMENT BY 1 NO MINVALUE NO MAXVALUE CACHE 1;

-- --------------------------------------------------------------
-- 2. TABLAS CATÁLOGO: VEHÍCULOS Y SERVICIOS
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.vehicles CASCADE;
CREATE TABLE public.vehicles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  name TEXT NOT NULL UNIQUE,
  description TEXT,
  image_url TEXT,
  is_active BOOLEAN DEFAULT true NOT NULL
);

DROP TABLE IF EXISTS public.services CASCADE;
CREATE TABLE public.services (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  name TEXT NOT NULL UNIQUE,
  description TEXT,
  image_url TEXT,
  is_active BOOLEAN DEFAULT true NOT NULL,
  display_order INT
);

-- --------------------------------------------------------------
-- 3. USUARIOS, COLABORADORES Y MATRÍCULAS
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.profiles CASCADE;
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  email TEXT,
  phone TEXT,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

DROP TABLE IF EXISTS public.collaborators CASCADE;
CREATE TABLE public.collaborators (
  id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  name TEXT,
  email TEXT,
  phone TEXT,
  matricula TEXT,
  status TEXT DEFAULT 'activo' NOT NULL,
  role TEXT DEFAULT 'colaborador' NOT NULL CHECK (lower(role) IN ('administrador','colaborador')),
  push_subscription JSONB,
  notes TEXT,
  updated_at timestamptz not null default now()
);

DROP TABLE IF EXISTS public.matriculas CASCADE;
CREATE TABLE public.matriculas (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  matricula TEXT NOT NULL,
  status TEXT DEFAULT 'activo' NOT NULL
);

CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS trigger AS $$
BEGIN
  new.updated_at = now();
  RETURN new;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_profiles_set_updated ON public.profiles;
CREATE TRIGGER trg_profiles_set_updated
BEFORE UPDATE ON public.profiles
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

DROP TRIGGER IF EXISTS trg_collaborators_touch_updated ON public.collaborators;
CREATE TRIGGER trg_collaborators_touch_updated
BEFORE UPDATE ON public.collaborators
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

-- --------------------------------------------------------------
-- 4. CONFIGURACIÓN DEL NEGOCIO
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.business CASCADE;
CREATE TABLE public.business (
  id integer primary key default 1,
  business_name text,
  address text,
  phone text,
  email text,
  rnc text CHECK (rnc ~ '^[0-9]{9,11}$' OR rnc IS NULL),
  quotation_rates jsonb,
  owner_user_id uuid references public.profiles(id) on delete set null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

CREATE OR REPLACE FUNCTION public.touch_updated_at()
RETURNS trigger AS $$
BEGIN
  new.updated_at = now();
  RETURN new;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_business_touch_updated ON public.business;
CREATE TRIGGER trg_business_touch_updated
BEFORE UPDATE ON public.business
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

INSERT INTO public.business (id, business_name) VALUES (1, 'Mi Negocio')
ON CONFLICT (id) DO NOTHING;

-- Compatibilidad
DROP TABLE IF EXISTS public.business_settings CASCADE;
CREATE TABLE public.business_settings (
  id integer primary key default 1,
  business_name text,
  address text,
  phone text,
  email text,
  rnc text,
  quotation_rates jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

DROP TRIGGER IF EXISTS trg_business_settings_touch_updated ON public.business_settings;
CREATE TRIGGER trg_business_settings_touch_updated
BEFORE UPDATE ON public.business_settings
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'business_settings_rnc_check'
  ) THEN
    ALTER TABLE public.business_settings
      ADD CONSTRAINT business_settings_rnc_check
      CHECK (rnc ~ '^[0-9]{9,11}$' OR rnc IS NULL);
  END IF;
END $$;

INSERT INTO public.business_settings (id, business_name) VALUES (1, 'Mi Negocio')
ON CONFLICT (id) DO NOTHING;

-- --------------------------------------------------------------
-- 5. HELPERS DE ROL
-- --------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.is_owner(uid uuid)
RETURNS boolean LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public AS $$
  SELECT EXISTS(SELECT 1 FROM public.business b WHERE b.owner_user_id = uid);
$$;

CREATE OR REPLACE FUNCTION public.is_admin(uid uuid)
RETURNS boolean LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public AS $$
  SELECT EXISTS(
    SELECT 1 FROM public.collaborators c WHERE c.id = uid AND lower(coalesce(c.role, 'colaborador')) = 'administrador'
  );
$$;

-- --------------------------------------------------------------
-- 6. ÓRDENES Y NOTIFICACIONES
-- --------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.generate_order_short_id()
RETURNS TEXT AS $$
DECLARE random_part TEXT; date_part TEXT; BEGIN
  random_part := upper(substring(md5(random()::text) from 1 for 6));
  date_part := to_char(current_date, 'YYYYMMDD');
  RETURN 'ORD-' || date_part || '-' || random_part;
END; $$ LANGUAGE plpgsql;

DROP TABLE IF EXISTS public.orders CASCADE;
CREATE TABLE public.orders (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  supabase_seq_id BIGINT UNIQUE DEFAULT nextval('public.orders_supabase_seq_id_seq'),
  client_tracking_id TEXT UNIQUE,
  short_id TEXT UNIQUE DEFAULT public.generate_order_short_id(),
  created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
  client_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  name TEXT NOT NULL,
  phone TEXT NOT NULL,
  email TEXT,
  rnc TEXT,
  empresa TEXT,
  service_id BIGINT REFERENCES public.services(id) ON DELETE SET NULL,
  vehicle_id BIGINT REFERENCES public.vehicles(id) ON DELETE SET NULL,
  service_questions JSONB,
  pickup TEXT,
  delivery TEXT,
  origin_coords JSONB,
  destination_coords JSONB,
  "date" DATE,
  "time" TIME,
  status TEXT DEFAULT 'Pendiente' NOT NULL,
  assigned_to UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  assigned_at TIMESTAMPTZ,
  accepted_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  completed_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  evidence_photos JSONB,
  rating JSONB,
  estimated_price TEXT DEFAULT 'Por confirmar',
  monto_cobrado NUMERIC,
  metodo_pago TEXT,
  tracking_data JSONB,
  tracking_url TEXT,
  last_collab_status TEXT,
  updated_at timestamptz not null default now()
);

-- client_tracking_id: asignación aleatoria 32 hex
ALTER TABLE public.orders ALTER COLUMN client_tracking_id SET DEFAULT encode(gen_random_bytes(16), 'hex');
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'orders_client_tracking_id_hex_check'
  ) THEN
    ALTER TABLE public.orders ADD CONSTRAINT orders_client_tracking_id_hex_check
      CHECK (client_tracking_id ~ '^[0-9a-f]{32}$');
  END IF;
END $$;

DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'orders_status_check'
  ) THEN
    ALTER TABLE public.orders ADD CONSTRAINT orders_status_check
      CHECK (status IN ('Pendiente','Aceptada','En proceso','Completado','Cancelado'));
  END IF;
END $$;

-- Tracking URL basada en client_tracking_id o short_id
CREATE OR REPLACE FUNCTION public.set_order_tracking_url()
RETURNS trigger AS $$
BEGIN
  IF new.tracking_url IS NULL OR new.tracking_url = '' THEN
    new.tracking_url := '/seguimiento.html?codigo=' || coalesce(new.client_tracking_id::text, new.short_id::text);
  END IF;
  RETURN new;
END; $$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_orders_set_tracking ON public.orders;
CREATE TRIGGER trg_orders_set_tracking
BEFORE INSERT ON public.orders
FOR EACH ROW EXECUTE FUNCTION public.set_order_tracking_url();

DROP TRIGGER IF EXISTS trg_orders_touch_updated ON public.orders;
CREATE TRIGGER trg_orders_touch_updated
BEFORE UPDATE ON public.orders
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

-- Notificaciones
DROP TABLE IF EXISTS public.notifications CASCADE;
CREATE TABLE public.notifications (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade,
  title text,
  body text,
  data jsonb,
  created_at timestamptz not null default now(),
  read_at timestamptz
);

-- Suscripciones push
DROP TABLE IF EXISTS public.push_subscriptions CASCADE;
CREATE TABLE public.push_subscriptions (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade,
  endpoint text not null,
  keys jsonb not null,
  created_at timestamptz not null default now()
);

-- --------------------------------------------------------------
-- 7. POLÍTICAS RLS
-- --------------------------------------------------------------
ALTER TABLE public.vehicles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.services ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.collaborators ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.matriculas ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.business ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.business_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.push_subscriptions ENABLE ROW LEVEL SECURITY;

-- Limpiar políticas conocidas
DO $$ BEGIN
  PERFORM 1;
  -- Vehicles/Services
  DROP POLICY IF EXISTS "public_read_vehicles" ON public.vehicles;
  DROP POLICY IF EXISTS "public_read_services" ON public.services;
  DROP POLICY IF EXISTS "owner_all_access_vehicles" ON public.vehicles;
  DROP POLICY IF EXISTS "owner_all_access_services" ON public.services;
  -- Profiles
  DROP POLICY IF EXISTS "public_read_profiles" ON public.profiles;
  DROP POLICY IF EXISTS "users_update_own_profile" ON public.profiles;
  -- Orders
  DROP POLICY IF EXISTS "public_insert_pending_orders" ON public.orders;
  DROP POLICY IF EXISTS "clients_read_own_orders" ON public.orders;
  DROP POLICY IF EXISTS "collaborator_read_pending_orders" ON public.orders;
  DROP POLICY IF EXISTS "collaborator_read_assigned_orders" ON public.orders;
  DROP POLICY IF EXISTS "collaborator_update_own_orders" ON public.orders;
  DROP POLICY IF EXISTS "owner_admin_all_orders" ON public.orders;
  -- collaborators/matriculas/business
  DROP POLICY IF EXISTS "collaborator_self_select" ON public.collaborators;
  DROP POLICY IF EXISTS "collaborator_self_update" ON public.collaborators;
  DROP POLICY IF EXISTS "owner_manage_collaborators" ON public.collaborators;
  DROP POLICY IF EXISTS "admin_manage_collaborators" ON public.collaborators;
  DROP POLICY IF EXISTS "collaborator_read_own_matriculas" ON public.matriculas;
  DROP POLICY IF EXISTS "owner_manage_matriculas" ON public.matriculas;
  DROP POLICY IF EXISTS "admin_manage_matriculas" ON public.matriculas;
  DROP POLICY IF EXISTS "owner_full_access_business" ON public.business;
  DROP POLICY IF EXISTS "owner_full_access_business_settings" ON public.business_settings;
  -- notifications/push
  DROP POLICY IF EXISTS "user_manage_own_push_subscriptions" ON public.push_subscriptions;
  DROP POLICY IF EXISTS "user_read_own_notifications" ON public.notifications;
  DROP POLICY IF EXISTS "user_manage_own_notifications" ON public.notifications;
END $$;

-- Vehicles/Services
CREATE POLICY "public_read_vehicles" ON public.vehicles FOR SELECT USING (true);
CREATE POLICY "public_read_services" ON public.services FOR SELECT USING (true);
CREATE POLICY "owner_all_access_vehicles" ON public.vehicles FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);
CREATE POLICY "owner_all_access_services" ON public.services FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Profiles
CREATE POLICY "public_read_profiles" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "users_update_own_profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Orders
CREATE POLICY "public_insert_pending_orders" ON public.orders
FOR INSERT WITH CHECK (
  status = 'Pendiente' AND (client_id IS NULL OR client_id = auth.uid())
);

CREATE POLICY "clients_read_own_orders" ON public.orders FOR SELECT USING (client_id = auth.uid());

CREATE POLICY "collaborator_read_pending_orders" ON public.orders FOR SELECT USING (
  public.is_admin(auth.uid()) OR public.is_owner(auth.uid()) OR status = 'Pendiente'
);

CREATE POLICY "collaborator_read_assigned_orders" ON public.orders FOR SELECT USING (
  public.is_admin(auth.uid()) OR public.is_owner(auth.uid()) OR assigned_to = auth.uid()
);

CREATE POLICY "collaborator_update_own_orders" ON public.orders FOR UPDATE USING (
  public.is_admin(auth.uid()) OR public.is_owner(auth.uid()) OR assigned_to = auth.uid()
);

CREATE POLICY "owner_admin_all_orders" ON public.orders FOR ALL USING (
  public.is_admin(auth.uid()) OR public.is_owner(auth.uid())
);

-- Push & Notifications
CREATE POLICY "user_manage_own_push_subscriptions" ON public.push_subscriptions FOR ALL USING (user_id = auth.uid());
CREATE POLICY "user_read_own_notifications" ON public.notifications FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "user_manage_own_notifications" ON public.notifications FOR UPDATE USING (user_id = auth.uid());

-- --------------------------------------------------------------
-- 8. RPCs
-- --------------------------------------------------------------
-- RPC: Aceptar orden por supabase_seq_id
CREATE OR REPLACE FUNCTION public.accept_order(order_id BIGINT)
RETURNS VOID LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE _now TIMESTAMPTZ := NOW(); BEGIN
  UPDATE public.orders
  SET status = 'En proceso',
      last_collab_status = 'en_camino_recoger',
      accepted_at = _now,
      tracking_data = (
        COALESCE(tracking_data, '[]'::jsonb) || jsonb_build_object(
          'status','en_camino_recoger','date',_now,'description','Orden aceptada, en camino a recoger'
        )
      )
  WHERE supabase_seq_id = order_id;
END; $$;

-- (Opcional) RPC: obtener orden por tracking id para lectura pública controlada
CREATE OR REPLACE FUNCTION public.get_order_by_tracking(tracking_id TEXT)
RETURNS public.orders
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT * FROM public.orders WHERE client_tracking_id = tracking_id LIMIT 1;
$$;

-- GRANT EXECUTE ON FUNCTION public.accept_order(BIGINT) TO anon, authenticated, service_role;
-- GRANT EXECUTE ON FUNCTION public.get_order_by_tracking(TEXT) TO anon, authenticated;

COMMIT;