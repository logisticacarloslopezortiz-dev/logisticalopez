-- =============================================================
--        ESQUEMA COMPLETO TLC (Versión lista para Supabase)
-- =============================================================
-- Incluye:
-- - Tablas base (vehículos, servicios)
-- - Perfiles, colaboradores y matrículas
-- - Órdenes con códigos aleatorios, notificaciones y suscripciones
-- - Configuración del negocio con RNC y dueño
-- - Políticas RLS seguras y triggers automáticos
-- =============================================================

-- --------------------------------------------------------------
-- 1. EXTENSIONES
-- --------------------------------------------------------------
create extension if not exists pgcrypto;

-- --------------------------------------------------------------
-- 2. TABLAS CATÁLOGO: VEHÍCULOS Y SERVICIOS
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.vehicles CASCADE;
CREATE TABLE public.vehicles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    image_url TEXT,
    is_active BOOLEAN DEFAULT true NOT NULL
);
COMMENT ON TABLE public.vehicles IS 'Catálogo de vehículos disponibles para los servicios.';

DROP TABLE IF EXISTS public.services CASCADE;
CREATE TABLE public.services (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    image_url TEXT,
    is_active BOOLEAN DEFAULT true NOT NULL,
    display_order INT
);
COMMENT ON TABLE public.services IS 'Catálogo de los servicios ofrecidos por el negocio.';

-- --------------------------------------------------------------
-- 3. USUARIOS Y COLABORADORES
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.profiles CASCADE;
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name TEXT,
    email TEXT,
    phone TEXT,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);
COMMENT ON TABLE public.profiles IS 'Datos públicos del usuario (sin roles, vinculados a auth.users).';

DROP TABLE IF EXISTS public.collaborators CASCADE;
CREATE TABLE public.collaborators (
    id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    name TEXT,
    email TEXT,
    phone TEXT,
    matricula TEXT,
    status TEXT DEFAULT 'activo' NOT NULL,
    role TEXT DEFAULT 'colaborador' NOT NULL CHECK (lower(role) IN ('administrador','colaborador')),
    push_subscription JSONB,
    notes TEXT,
    updated_at timestamptz not null default now()
);
COMMENT ON TABLE public.collaborators IS 'Datos operativos de colaboradores.';

DROP TABLE IF EXISTS public.matriculas CASCADE;
CREATE TABLE public.matriculas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    matricula TEXT NOT NULL,
    status TEXT DEFAULT 'activo' NOT NULL
);
COMMENT ON TABLE public.matriculas IS 'Matrículas/placas de los colaboradores.';

CREATE INDEX IF NOT EXISTS idx_matriculas_user_id ON public.matriculas(user_id);
CREATE INDEX IF NOT EXISTS idx_collaborators_status ON public.collaborators(status);
CREATE INDEX IF NOT EXISTS idx_collaborators_role ON public.collaborators(role);
CREATE INDEX IF NOT EXISTS idx_collaborators_email ON public.collaborators(email);
CREATE INDEX IF NOT EXISTS idx_profiles_email ON public.profiles(email);

-- Trigger para updated_at
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS trigger AS $$
BEGIN
  new.updated_at = now();
  RETURN new;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_profiles_set_updated ON public.profiles;
CREATE TRIGGER trg_profiles_set_updated
BEFORE UPDATE ON public.profiles
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

DROP TRIGGER IF EXISTS trg_collaborators_touch_updated ON public.collaborators;
CREATE TRIGGER trg_collaborators_touch_updated
BEFORE UPDATE ON public.collaborators
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

-- Sincronizar push_subscription de colaboradores hacia tabla estándar push_subscriptions
CREATE OR REPLACE FUNCTION public.sync_collaborator_push_subscription()
RETURNS trigger AS $$
DECLARE
  endpoint text;
  keys jsonb;
BEGIN
  IF NEW.push_subscription IS NULL THEN
    RETURN NEW;
  END IF;
  endpoint := NEW.push_subscription->>'endpoint';
  keys := NEW.push_subscription->'keys';
  IF endpoint IS NULL OR endpoint = '' THEN
    RETURN NEW;
  END IF;
  INSERT INTO public.push_subscriptions(user_id, endpoint, keys, created_at)
  VALUES (NEW.id, endpoint, COALESCE(keys, '{}'::jsonb), now())
  ON CONFLICT (user_id, endpoint)
  DO UPDATE SET keys = EXCLUDED.keys;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_collaborators_sync_push_subscription ON public.collaborators;
CREATE TRIGGER trg_collaborators_sync_push_subscription
AFTER UPDATE OF push_subscription ON public.collaborators
FOR EACH ROW EXECUTE FUNCTION public.sync_collaborator_push_subscription();

-- Backfill inicial de colaboradores con push_subscription definido
-- (Movido) Este backfill se ejecuta después de crear la tabla public.push_subscriptions.

-- --------------------------------------------------------------
-- 4. CONFIGURACIÓN DEL NEGOCIO
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.business CASCADE;
CREATE TABLE public.business (
  id integer primary key default 1,
  business_name text,
  address text,
  phone text,
  email text,
  rnc text CHECK (rnc ~ '^[0-9]{9,11}$' OR rnc IS NULL),
  quotation_rates jsonb,
  owner_user_id uuid references public.profiles(id) on delete set null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

COMMENT ON TABLE public.business IS 'Configuración general del negocio.';

CREATE INDEX IF NOT EXISTS idx_business_owner ON public.business(owner_user_id);
CREATE INDEX IF NOT EXISTS idx_business_rnc ON public.business(rnc);

-- Trigger updated_at
CREATE OR REPLACE FUNCTION public.touch_updated_at()
RETURNS trigger AS $$
BEGIN
  new.updated_at = now();
  RETURN new;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_business_touch_updated ON public.business;
CREATE TRIGGER trg_business_touch_updated
BEFORE UPDATE ON public.business
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

-- Seed inicial
INSERT INTO public.business (id, business_name, address, phone, email)
VALUES (1, 'Mi Negocio', '', '', '')
ON CONFLICT (id) DO NOTHING;

-- --------------------------------------------------------------
-- 4.b COMPATIBILIDAD: business_settings (para proyectos antiguos)
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.business_settings CASCADE;
CREATE TABLE public.business_settings (
  id integer primary key default 1,
  business_name text,
  address text,
  phone text,
  email text,
  rnc text,
  quotation_rates jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

COMMENT ON TABLE public.business_settings IS 'Tabla de compatibilidad para configuraciones del negocio; preferir public.business.';

-- Trigger updated_at (reutiliza la función touch_updated_at)
DROP TRIGGER IF EXISTS trg_business_settings_touch_updated ON public.business_settings;
CREATE TRIGGER trg_business_settings_touch_updated
BEFORE UPDATE ON public.business_settings
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

-- Consistencia de RNC
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'business_settings_rnc_check'
  ) THEN
    ALTER TABLE public.business_settings
      ADD CONSTRAINT business_settings_rnc_check
      CHECK (rnc ~ '^[0-9]{9,11}$' OR rnc IS NULL);
  END IF;
END $$;

-- Seed inicial de compatibilidad
INSERT INTO public.business_settings (id, business_name, address, phone, email)
VALUES (1, 'Mi Negocio', '', '', '')
ON CONFLICT (id) DO NOTHING;

-- --------------------------------------------------------------
-- 5.a FUNCIONES DE ROL (helpers)
-- --------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.is_owner(uid uuid)
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS(
    SELECT 1 FROM public.business b WHERE b.owner_user_id = uid
  );
$$;

CREATE OR REPLACE FUNCTION public.is_admin(uid uuid)
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS(
    SELECT 1 FROM public.collaborators c
    WHERE c.id = uid AND lower(coalesce(c.role, 'colaborador')) = 'administrador'
  );
$$;

-- --------------------------------------------------------------
-- 5. ÓRDENES Y NOTIFICACIONES
-- --------------------------------------------------------------
-- Ya no necesitamos la secuencia para los IDs cortos
DROP SEQUENCE IF EXISTS public.orders_short_id_seq;

CREATE OR REPLACE FUNCTION public.generate_order_short_id()
RETURNS TEXT AS $$
DECLARE
    random_part TEXT;
    date_part TEXT;
BEGIN
    -- Generar parte aleatoria (equivalente a Math.random().toString(36).substring(2, 8).toUpperCase())
    random_part := upper(substring(md5(random()::text) from 1 for 6));
    
    -- Obtener fecha actual en formato YYYYMMDD
    date_part := to_char(current_date, 'YYYYMMDD');
    
    -- Combinar en formato ORD-YYYYMMDD-RANDOM
    RETURN 'ORD-' || date_part || '-' || random_part;
END;
$$ LANGUAGE plpgsql;

DROP TABLE IF EXISTS public.orders CASCADE;
CREATE TABLE public.orders (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    short_id TEXT UNIQUE DEFAULT public.generate_order_short_id(),
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    client_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    phone TEXT NOT NULL,
    email TEXT,
    rnc TEXT,
    empresa TEXT,
    service_id BIGINT REFERENCES public.services(id) ON DELETE SET NULL,
    vehicle_id BIGINT REFERENCES public.vehicles(id) ON DELETE SET NULL,
    service_questions JSONB,
    pickup TEXT,
    delivery TEXT,
    origin_coords JSONB,
    destination_coords JSONB,
    "date" DATE,
    "time" TIME,
    status TEXT DEFAULT 'Pendiente' NOT NULL,
    assigned_to UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    assigned_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    completed_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    evidence_photos JSONB,
    rating JSONB,
    estimated_price TEXT DEFAULT 'Por confirmar',
    monto_cobrado NUMERIC,
    metodo_pago TEXT,
    tracking_data JSONB,
    tracking_url TEXT,
    updated_at timestamptz not null default now()
);

CREATE INDEX IF NOT EXISTS idx_orders_status ON public.orders(status);
CREATE INDEX IF NOT EXISTS idx_orders_date ON public.orders("date");
CREATE INDEX IF NOT EXISTS idx_orders_assigned_to ON public.orders(assigned_to);
CREATE INDEX IF NOT EXISTS idx_orders_client_id ON public.orders(client_id);

-- Constraint de estado permitido
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'orders_status_check'
  ) THEN
    ALTER TABLE public.orders
      ADD CONSTRAINT orders_status_check
      CHECK (status IN ('Pendiente','Aceptada','En curso','Completada','Cancelada'));
  END IF;
END $$;

-- Trigger: setear tracking_url automáticamente al crear la orden
CREATE OR REPLACE FUNCTION public.set_order_tracking_url()
RETURNS trigger AS $$
BEGIN
  IF new.tracking_url IS NULL OR new.tracking_url = '' THEN
    new.tracking_url := '/seguimiento.html?codigo=' || coalesce(new.short_id::text, new.id::text);
  END IF;
  RETURN new;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_orders_set_tracking ON public.orders;
CREATE TRIGGER trg_orders_set_tracking
BEFORE INSERT ON public.orders
FOR EACH ROW EXECUTE FUNCTION public.set_order_tracking_url();

-- Trigger updated_at para orders
DROP TRIGGER IF EXISTS trg_orders_touch_updated ON public.orders;
CREATE TRIGGER trg_orders_touch_updated
BEFORE UPDATE ON public.orders
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

-- Asegurar metadata de completado (completed_at y completed_by) al cambiar a 'Completada'
CREATE OR REPLACE FUNCTION public.ensure_completed_metadata()
RETURNS trigger AS $$
BEGIN
  IF NEW.status = 'Completada' THEN
    -- Establecer fecha de completado si falta
    IF NEW.completed_at IS NULL THEN
      NEW.completed_at := now();
    END IF;
    -- Establecer colaborador que completó si falta
    IF NEW.completed_by IS NULL THEN
      -- Preferir el asignado; si no, el usuario autenticado
      NEW.completed_by := COALESCE(NEW.assigned_to, auth.uid());
    END IF;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_orders_ensure_completed_metadata ON public.orders;
CREATE TRIGGER trg_orders_ensure_completed_metadata
BEFORE UPDATE ON public.orders
FOR EACH ROW
WHEN (OLD.status IS DISTINCT FROM NEW.status)
EXECUTE FUNCTION public.ensure_completed_metadata();

-- Notificaciones
DROP TABLE IF EXISTS public.notifications CASCADE;
CREATE TABLE public.notifications (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade,
  title text,
  body text,
  data jsonb,
  created_at timestamptz not null default now(),
  read_at timestamptz
);
CREATE INDEX IF NOT EXISTS idx_notifications_user ON public.notifications(user_id);
-- Índice para ordenar por fecha y filtrar no leídas
CREATE INDEX IF NOT EXISTS idx_notifications_created_at ON public.notifications(created_at);
CREATE INDEX IF NOT EXISTS idx_notifications_unread ON public.notifications((read_at IS NULL)) WHERE read_at IS NULL;

-- Suscripciones push
DROP TABLE IF EXISTS public.push_subscriptions CASCADE;
CREATE TABLE public.push_subscriptions (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade,
  endpoint text not null,
  keys jsonb not null,
  created_at timestamptz not null default now()
);
CREATE INDEX IF NOT EXISTS idx_push_subscriptions_user ON public.push_subscriptions(user_id);
-- Evitar duplicados de endpoint por usuario
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND indexname = 'uniq_push_subscriptions_user_endpoint'
  ) THEN
    CREATE UNIQUE INDEX uniq_push_subscriptions_user_endpoint
    ON public.push_subscriptions(user_id, endpoint);
  END IF;
END $$;

ALTER TABLE public.push_subscriptions ADD COLUMN IF NOT EXISTS client_contact_id uuid REFERENCES public.clients(id) ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_push_subscriptions_contact ON public.push_subscriptions(client_contact_id);
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes WHERE schemaname = 'public' AND indexname = 'uniq_push_subscriptions_contact_endpoint'
  ) THEN
    CREATE UNIQUE INDEX uniq_push_subscriptions_contact_endpoint
    ON public.push_subscriptions(client_contact_id, endpoint);
  END IF;
END $$;
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'chk_push_owner'
  ) THEN
    ALTER TABLE public.push_subscriptions
      ADD CONSTRAINT chk_push_owner
      CHECK (user_id IS NOT NULL OR client_contact_id IS NOT NULL);
  END IF;
END $$;

-- Backfill inicial de colaboradores con push_subscription definido
DO $$ BEGIN
  INSERT INTO public.push_subscriptions(user_id, endpoint, keys, created_at)
  SELECT c.id,
         c.push_subscription->>'endpoint',
         COALESCE(c.push_subscription->'keys', '{}'::jsonb),
         now()
  FROM public.collaborators c
  WHERE c.push_subscription IS NOT NULL
    AND (c.push_subscription->>'endpoint') IS NOT NULL
  ON CONFLICT (user_id, endpoint)
  DO UPDATE SET keys = EXCLUDED.keys;
END $$;

-- --------------------------------------------------------------
-- 5.c ACTA DE COMPLETADO (vincula cliente y orden)
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.order_completion_receipts CASCADE;
CREATE TABLE public.order_completion_receipts (
  id bigint generated by default as identity primary key,
  order_id bigint not null references public.orders(id) on delete cascade,
  client_id uuid references public.profiles(id) on delete set null,
  collaborator_id uuid references public.profiles(id) on delete set null,
  signed_by_client_at timestamptz,
  signed_by_collaborator_at timestamptz,
  signature_data jsonb,
  notes text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique(order_id)
);
COMMENT ON TABLE public.order_completion_receipts IS 'Acta/acuse de completado entre cliente y orden, con firmas y metadatos.';
CREATE INDEX IF NOT EXISTS idx_receipts_order_id ON public.order_completion_receipts(order_id);
CREATE INDEX IF NOT EXISTS idx_receipts_client_id ON public.order_completion_receipts(client_id);

-- Trigger updated_at para order_completion_receipts
DROP TRIGGER IF EXISTS trg_receipts_touch_updated ON public.order_completion_receipts;
CREATE TRIGGER trg_receipts_touch_updated
BEFORE UPDATE ON public.order_completion_receipts
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

-- Crear acta automáticamente al completar una orden
CREATE OR REPLACE FUNCTION public.create_completion_receipt_on_order_complete()
RETURNS trigger AS $$
BEGIN
  IF new.status = 'Completada' THEN
    -- Crear acta si no existe
    IF NOT EXISTS (
      SELECT 1 FROM public.order_completion_receipts r WHERE r.order_id = new.id
    ) THEN
      INSERT INTO public.order_completion_receipts(order_id, client_id, collaborator_id, signed_by_collaborator_at)
      VALUES (new.id, new.client_id, new.assigned_to, COALESCE(new.completed_at, now()));
    END IF;
    -- Si hay completed_at y client_id, no firmamos automáticamente al cliente; queda para la app
  END IF;
  RETURN new;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_orders_create_receipt ON public.orders;
CREATE TRIGGER trg_orders_create_receipt
AFTER UPDATE ON public.orders
FOR EACH ROW
WHEN (OLD.status IS DISTINCT FROM NEW.status)
EXECUTE FUNCTION public.create_completion_receipt_on_order_complete();

-- --------------------------------------------------------------
-- 6. POLÍTICAS RLS (SEGURIDAD)
-- --------------------------------------------------------------
ALTER TABLE public.vehicles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.services ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.collaborators ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.matriculas ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.business ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.business_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.push_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.order_completion_receipts ENABLE ROW LEVEL SECURITY;

-- Limpieza previa de políticas antiguas
DROP POLICY IF EXISTS "public_read_vehicles" ON public.vehicles;
DROP POLICY IF EXISTS "public_read_services" ON public.services;
DROP POLICY IF EXISTS "owner_all_access_vehicles" ON public.vehicles;
DROP POLICY IF EXISTS "owner_all_access_services" ON public.services;
DROP POLICY IF EXISTS "public_read_profiles" ON public.profiles;
DROP POLICY IF EXISTS "users_update_own_profile" ON public.profiles;
DROP POLICY IF EXISTS "public_insert_pending_orders" ON public.orders;
DROP POLICY IF EXISTS "clients_read_own_orders" ON public.orders;
DROP POLICY IF EXISTS "collaborator_read_pending_orders" ON public.orders;
DROP POLICY IF EXISTS "collaborator_read_assigned_orders" ON public.orders;
DROP POLICY IF EXISTS "collaborator_update_own_orders" ON public.orders;
DROP POLICY IF EXISTS "owner_admin_all_orders" ON public.orders;
DROP POLICY IF EXISTS "collaborator_self_select" ON public.collaborators;
DROP POLICY IF EXISTS "collaborator_self_update" ON public.collaborators;
DROP POLICY IF EXISTS "owner_manage_collaborators" ON public.collaborators;
DROP POLICY IF EXISTS "admin_manage_collaborators" ON public.collaborators;
DROP POLICY IF EXISTS "collaborator_read_own_matriculas" ON public.matriculas;
DROP POLICY IF EXISTS "owner_manage_matriculas" ON public.matriculas;
DROP POLICY IF EXISTS "admin_manage_matriculas" ON public.matriculas;
DROP POLICY IF EXISTS "owner_full_access_business" ON public.business;
DROP POLICY IF EXISTS "owner_full_access_business_settings" ON public.business_settings;
DROP POLICY IF EXISTS "user_manage_own_push_subscriptions" ON public.push_subscriptions;
DROP POLICY IF EXISTS "user_read_own_notifications" ON public.notifications;
DROP POLICY IF EXISTS "user_manage_own_notifications" ON public.notifications;
DROP POLICY IF EXISTS "client_read_own_receipts" ON public.order_completion_receipts;
DROP POLICY IF EXISTS "collaborator_manage_assigned_receipts" ON public.order_completion_receipts;
DROP POLICY IF EXISTS "admin_manage_receipts" ON public.order_completion_receipts;

-- Vehículos y servicios
CREATE POLICY "public_read_vehicles" ON public.vehicles FOR SELECT USING (true);
CREATE POLICY "public_read_services" ON public.services FOR SELECT USING (true);
CREATE POLICY "owner_all_access_vehicles" ON public.vehicles FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);
CREATE POLICY "owner_all_access_services" ON public.services FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Profiles
CREATE POLICY "public_read_profiles" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "users_update_own_profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Orders
-- Importante para evitar el error RLS en INSERT desde cliente anónimo o autenticado sin client_id
-- Permitimos insertar órdenes en estado Pendiente, asignando client_id NULL o igual a auth.uid()
CREATE POLICY "public_insert_pending_orders" ON public.orders
FOR INSERT
WITH CHECK (
  status = 'Pendiente' AND (client_id IS NULL OR client_id = auth.uid())
);

CREATE POLICY "clients_read_own_orders" ON public.orders FOR SELECT USING (client_id = auth.uid());
CREATE POLICY "collaborator_read_pending_orders" ON public.orders FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  ) AND status = 'Pendiente'
);
CREATE POLICY "collaborator_read_assigned_orders" ON public.orders FOR SELECT USING (assigned_to = auth.uid());
CREATE POLICY "collaborator_update_own_orders" ON public.orders FOR UPDATE USING (assigned_to = auth.uid());
-- (Eliminado) Política duplicada owner_admin_all_orders: se reemplaza por admin_all_orders condicional más abajo.

-- Permitir lectura pública de órdenes finalizadas/canceladas para historial
DROP POLICY IF EXISTS "public_read_completed_orders" ON public.orders;
CREATE POLICY "public_read_completed_orders" ON public.orders
FOR SELECT USING (
  status IN ('Completada','Cancelada')
);

-- Collaborators y Matrículas
CREATE POLICY "collaborator_self_select" ON public.collaborators FOR SELECT USING (auth.uid() = id);
CREATE POLICY "collaborator_self_update" ON public.collaborators FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "owner_manage_collaborators" ON public.collaborators FOR ALL USING (
  public.is_owner(auth.uid())
);
CREATE POLICY "admin_manage_collaborators" ON public.collaborators FOR ALL USING (
  public.is_admin(auth.uid())
);

CREATE POLICY "collaborator_read_own_matriculas" ON public.matriculas FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "owner_manage_matriculas" ON public.matriculas FOR ALL USING (
  public.is_owner(auth.uid())
);
CREATE POLICY "admin_manage_matriculas" ON public.matriculas FOR ALL USING (
  public.is_admin(auth.uid())
);

-- Business
CREATE POLICY "owner_full_access_business" ON public.business
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Business Settings (compatibilidad)
CREATE POLICY "owner_full_access_business_settings" ON public.business_settings
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Push Subscriptions
CREATE POLICY "user_manage_own_push_subscriptions" ON public.push_subscriptions
FOR ALL USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

-- Notifications
CREATE POLICY "user_manage_own_notifications" ON public.notifications
FOR ALL USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

-- Permitir a administradores/owner gestionar notificaciones de cualquier usuario
DROP POLICY IF EXISTS "admin_manage_notifications" ON public.notifications;
CREATE POLICY "admin_manage_notifications" ON public.notifications
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- (Opcional) Permitir a administradores/owner leer suscripciones push para soporte
DROP POLICY IF EXISTS "admin_read_push_subscriptions" ON public.push_subscriptions;
CREATE POLICY "admin_read_push_subscriptions" ON public.push_subscriptions
FOR SELECT USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

CREATE POLICY "anon_insert_push_by_contact" ON public.push_subscriptions
FOR INSERT TO anon, authenticated
WITH CHECK (client_contact_id IS NOT NULL);

-- Order Completion Receipts (Acta de completado)
CREATE POLICY "client_read_own_receipts" ON public.order_completion_receipts
FOR SELECT USING (client_id = auth.uid());

CREATE POLICY "collaborator_manage_assigned_receipts" ON public.order_completion_receipts
FOR ALL USING (
  EXISTS (
    SELECT 1 FROM public.orders o
    WHERE o.id = order_id AND o.assigned_to = auth.uid()
  )
) WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.orders o
    WHERE o.id = order_id AND o.assigned_to = auth.uid()
  )
);

CREATE POLICY "admin_manage_receipts" ON public.order_completion_receipts
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- --------------------------------------------------------------
-- 7. SEED DE CATÁLOGOS
-- --------------------------------------------------------------
INSERT INTO public.vehicles (name, description, image_url, is_active) VALUES
('Camión Pequeño', '14 pies', 'https://i.postimg.cc/DynCkfnV/camionpequeno.jpg', true),
('Furgoneta', 'Ideal para paquetería y cargas ligeras', 'https://i.postimg.cc/RV4P5C9f/furgoneta.jpg', true),
('Grúa Vehicular', 'Para remolque de autos y jeepetas', 'https://i.postimg.cc/hvgBTFmy/grua-vehiculos.jpg', true),
('Camión Grande', '22 a 28 pies', 'https://i.postimg.cc/44z8SHCc/camiongrande.jpg', true),
('Grúa de Carga', 'Para izado y movimiento de carga', 'https://i.postimg.cc/0yHZwpSf/grua.png', true),
('Motor', 'Para paquetería y entregas rápidas', 'https://i.postimg.cc/JMNgTvmd/motor.jpg', true),
('Camión Abierto', 'Carga y transporte de materiales y mineros', 'https://i.postimg.cc/Kvx9ScFT/camionminero.jpg', true)
ON CONFLICT (name) DO NOTHING;

INSERT INTO public.services (name, description, image_url, is_active, display_order) VALUES
('Transporte Comercial', 'Transporte seguro de mercancías comerciales.', 'https://i.postimg.cc/sXCdCFTD/transporte-comercial.png', true, 1),
('Paquetería', 'Envíos de paquetes seguros y rápidos.', 'https://i.postimg.cc/zBYZYmx8/paqueteria.png', true, 2),
('Carga Pesada', 'Especialistas en transporte de carga pesada.', 'https://i.postimg.cc/B65b1fbv/pesado.jpg', true, 3),
('Flete', 'Servicios de flete a nivel nacional.', 'https://i.postimg.cc/15vQnj3w/flete.png', true, 4),
('Mudanza', 'Mudanza residencial y comercial.', 'https://i.postimg.cc/HszyJd5m/mudanza.jpg', true, 5),
('Grúa Vehículo', 'Remolque de vehículos.', 'https://i.postimg.cc/hvgBTFmy/grua-vehiculos.jpg', true, 6),
('Botes Mineros', 'Alquiler y transporte de botes.', 'https://i.postimg.cc/gzL29mkt/botes-minenos.png', true, 7),
('Grúa de Carga', 'Movimiento de carga pesada.', 'https://i.postimg.cc/sDjz2rsx/grua-carga.png', true, 8)
ON CONFLICT (name) DO NOTHING;

-- =============================================================
-- Normaliza políticas de administrador para evitar dependencias recursivas sobre public.business
-- Reemplaza políticas 'owner_*' por políticas basadas en rol 'administrador' en collaborators

-- Vehículos
drop policy if exists "owner_all_access_vehicles" on public.vehicles;
drop policy if exists "admin_all_access_vehicles" on public.vehicles;
create policy "admin_all_access_vehicles" on public.vehicles
for all using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Servicios
drop policy if exists "owner_all_access_services" on public.services;
drop policy if exists "admin_all_access_services" on public.services;
create policy "admin_all_access_services" on public.services
for all using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Órdenes
drop policy if exists "owner_all_orders" on public.orders;
drop policy if exists "admin_all_orders" on public.orders;
-- (Eliminado) Bloque duplicado de admin_all_orders; se declara en DO $$ unificado.

-- Colaboradores (gestión completa por administradores)
drop policy if exists "owner_manage_collaborators" on public.collaborators;
drop policy if exists "admin_manage_collaborators" on public.collaborators;
create policy "admin_manage_collaborators" on public.collaborators
for all using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Matrículas
drop policy if exists "owner_manage_matriculas" on public.matriculas;
drop policy if exists "admin_manage_matriculas" on public.matriculas;
create policy "admin_manage_matriculas" on public.matriculas
for all using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Nota: Las políticas específicas de colaboradores (self select/update) y de órdenes para colaboradores
-- permanecen intactas en otras migraciones recientes.

create or replace function public.is_admin(uid uuid)
returns boolean as $$
  select exists (
    select 1
    from public.collaborators
    where id = uid
    and lower(role) = 'administrador'
  );
$$ language sql stable;

-- =============================================================
-- MIGRACIÓN: Normalización de estados de orders y utilidades para Edge Functions
-- Objetivo:
--  - Evitar errores 23514 (violación de orders_status_check)
--  - Normalizar y validar estados con un set controlado y trigger
--  - Ajustar RLS para updates de estado por colaboradores/admin
--  - Agregar tabla simple de logs para depuración de Edge Functions (opcional)
-- =============================================================

-- 1) Ampliar temporalmente el constraint de status para permitir variantes usadas
DO $$ BEGIN
  IF EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'orders_status_check') THEN
    ALTER TABLE public.orders DROP CONSTRAINT orders_status_check;
  END IF;
END $$;

-- 2) Crear ENUM opcional o mantener TEXT con CHECK. Usaremos TEXT+CHECK + trigger de normalización.
-- Catálogo de estados permitidos canónicos
-- Pendiente, Aceptada, En curso, Completada, Cancelada
-- Consideraremos variantes comunes: 'Aceptado', 'en_progreso', 'en curso', 'ACEPTADA', etc.

-- 3) Función de normalización de estado
CREATE OR REPLACE FUNCTION public.normalize_order_status(in_status text)
RETURNS text
LANGUAGE plpgsql
AS $$
DECLARE
  s text := trim(both from coalesce(in_status, ''));
BEGIN
  IF s = '' THEN
    RETURN 'Pendiente';
  END IF;
  s := replace(lower(s), '_', ' ');

  -- mapear variantes a canónicos
  IF s IN ('pendiente') THEN RETURN 'Pendiente'; END IF;
  IF s IN ('aceptada','aceptado','aceptar','accepted') THEN RETURN 'Aceptada'; END IF;
  IF s IN ('en curso','en progreso','en proceso','en transito','en tránsito') THEN RETURN 'En curso'; END IF;
  IF s IN ('completada','completado','finalizada','terminada') THEN RETURN 'Completada'; END IF;
  IF s IN ('cancelada','cancelado','anulada') THEN RETURN 'Cancelada'; END IF;

  -- Si llega algo desconocido, forzar a 'Pendiente' para no romper flujos
  RETURN 'Pendiente';
END $$;

-- 4) Trigger BEFORE INSERT/UPDATE para normalizar y validar
CREATE OR REPLACE FUNCTION public.orders_status_guard()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.status := public.normalize_order_status(NEW.status);
  -- Validación final
  IF NEW.status NOT IN ('Pendiente','Aceptada','En curso','Completada','Cancelada') THEN
    RAISE EXCEPTION 'Estado no permitido: %', NEW.status USING ERRCODE = '23514';
  END IF;
  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS trg_orders_status_guard ON public.orders;
CREATE TRIGGER trg_orders_status_guard
BEFORE INSERT OR UPDATE ON public.orders
FOR EACH ROW EXECUTE FUNCTION public.orders_status_guard();

-- 5) Reaplicar CHECK para asegurar integridad futura
ALTER TABLE public.orders
  ADD CONSTRAINT orders_status_check
  CHECK (status IN ('Pendiente','Aceptada','En curso','Completada','Cancelada'));

-- 6) Normalizar datos existentes a canónicos
UPDATE public.orders
SET status = public.normalize_order_status(status)
WHERE status IS NOT NULL;

-- 7) RLS: asegurar que colaboradores/admin puedan actualizar su orden a estados válidos
-- Ya existe collaborator_update_own_orders (assigned_to = auth.uid()). La dejamos.
-- Reforzamos owner/admin all access por si necesitan corregir estados
-- (Eliminado) DO $$ para owner_admin_all_orders: se usa admin_all_orders unificado más abajo.


-- 8) Tabla simple de logs para Edge Functions (opcional)
CREATE TABLE IF NOT EXISTS public.function_logs (
  id bigint generated by default as identity primary key,
  fn_name text not null,
  level text not null default 'error',
  message text,
  payload jsonb,
  created_at timestamptz not null default now()
);

-- Policy: solo admin/owner puede leer; service_role escribe sin RLS
ALTER TABLE public.function_logs ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS function_logs_read_admin ON public.function_logs;
CREATE POLICY function_logs_read_admin ON public.function_logs
FOR SELECT USING (public.is_owner(auth.uid()) OR public.is_admin(auth.uid()));

-- 9) Nota de integración frontend/backend
-- - En inserts, no envíes status o envía 'Pendiente'.
-- - En updates desde panel-colaborador, puedes enviar 'Aceptada' o 'En curso' y el trigger lo normaliza
--   aunque llegue 'aceptado' o 'en_progreso'.
-- - Si tu Edge Function cambia estados, no se verá afectada si corre con service_role.

-- FIN MIGRACIÓN

-- --------------------------------------------------------------
-- 6.b FACTURAS (INVOICES)
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.invoices CASCADE;
CREATE TABLE public.invoices (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  order_id bigint references public.orders(id) on delete set null,
  client_id uuid references public.profiles(id) on delete set null,
  file_path text not null,
  file_url text,
  total numeric,
  status text default 'generada',
  data jsonb
);

ALTER TABLE public.invoices ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "owner_admin_all_invoices" ON public.invoices;
CREATE POLICY "owner_admin_all_invoices" ON public.invoices
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

DROP POLICY IF EXISTS "client_read_own_invoices" ON public.invoices;
CREATE POLICY "client_read_own_invoices" ON public.invoices
FOR SELECT USING (
  client_id = auth.uid()
);


-- =============================================================
-- Migration: Add Profile Sync Trigger and Fix RLS Policies
-- =============================================================

-- 1. Add trigger to sync profile names from collaborators
CREATE OR REPLACE FUNCTION public.sync_profile_name()
RETURNS trigger AS $$
BEGIN
  -- Update the profile's full_name when collaborator name changes
  UPDATE public.profiles
  SET 
    full_name = NEW.name,
    email = NEW.email,
    phone = NEW.phone,
    updated_at = NOW()
  WHERE id = NEW.id;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sync_profile_name ON public.collaborators;
CREATE TRIGGER trg_sync_profile_name
AFTER INSERT OR UPDATE OF name, email, phone ON public.collaborators
FOR EACH ROW EXECUTE FUNCTION public.sync_profile_name();

-- 2. Fix RLS policies for orders
DROP POLICY IF EXISTS "public_insert_pending_orders" ON public.orders;
CREATE POLICY "public_insert_pending_orders" ON public.orders
FOR INSERT
WITH CHECK (
  -- Allow pending orders from any client (including anonymous)
  status = 'Pendiente' AND
  -- Prevent hijacking by ensuring client_id is either null or matches auth
  (client_id IS NULL OR client_id = auth.uid()) AND
  -- Additional safety: assigned_to must be null for new orders
  assigned_to IS NULL
);

-- 3. More permissive read policy for orders (helps with 401s)
DROP POLICY IF EXISTS "public_read_pending_orders" ON public.orders;
CREATE POLICY "public_read_pending_orders" ON public.orders
FOR SELECT USING (
  -- Allow reading pending orders or own orders
  status = 'Pendiente' OR
  client_id = auth.uid() OR
  assigned_to = auth.uid() OR
  -- Admins and owners can read all
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 4. Make sure collaborator operations work
DROP POLICY IF EXISTS "collaborator_all_on_own_orders" ON public.orders;
CREATE POLICY "collaborator_all_on_own_orders" ON public.orders
FOR ALL USING (
  -- Must be an active collaborator
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  ) AND (
    -- And either the order is assigned to them
    assigned_to = auth.uid() OR
    -- Or it's pending (allowing them to accept it)
    status = 'Pendiente'
  )
) WITH CHECK (
  -- For inserts/updates, must be an active collaborator
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  )
);

-- 5. Fix collaborator self-management
DROP POLICY IF EXISTS "collaborator_self_manage" ON public.collaborators;
CREATE POLICY "collaborator_self_manage" ON public.collaborators
FOR ALL USING (
  -- Collaborators can manage their own profiles
  auth.uid() = id OR
  -- Admins and owners can manage all
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
) WITH CHECK (
  -- Similar check for insert/update
  auth.uid() = id OR
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 6. Add admin insert policy for collaborators (helps with creation)
DROP POLICY IF EXISTS "admin_insert_collaborators" ON public.collaborators;
CREATE POLICY "admin_insert_collaborators" ON public.collaborators
FOR INSERT
WITH CHECK (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 7. Ensure admins can manage profiles
DROP POLICY IF EXISTS "admin_manage_profiles" ON public.profiles;
CREATE POLICY "admin_manage_profiles" ON public.profiles
FOR ALL USING (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 8. Add profile insert for new users
DROP POLICY IF EXISTS "auth_insert_profile" ON public.profiles;
CREATE POLICY "auth_insert_profile" ON public.profiles
FOR INSERT
WITH CHECK (
  -- New users can create their profile
  auth.uid() = id
);


-- =============================================================
-- Migration: Add Profile Sync Trigger and Fix RLS Policies
-- =============================================================

-- 1. Add trigger to sync profile names from collaborators
CREATE OR REPLACE FUNCTION public.sync_profile_name()
RETURNS trigger AS $$
BEGIN
  -- Upsert into public.profiles to ensure a profile row always exists for the collaborator
  INSERT INTO public.profiles (id, full_name, email, phone, created_at, updated_at)
  VALUES (NEW.id, NEW.name, NEW.email, NEW.phone, NOW(), NOW())
  ON CONFLICT (id) DO UPDATE SET
    full_name = EXCLUDED.full_name,
    email = EXCLUDED.email,
    phone = EXCLUDED.phone,
    updated_at = NOW();

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sync_profile_name ON public.collaborators;
CREATE TRIGGER trg_sync_profile_name
AFTER INSERT OR UPDATE OF name, email, phone ON public.collaborators
FOR EACH ROW EXECUTE FUNCTION public.sync_profile_name();

-- 2. Fix RLS policies for orders
-- Ensure RLS is enabled on the tables we will modify (safe to run multiple times)
ALTER TABLE IF EXISTS public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.collaborators ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "public_insert_pending_orders" ON public.orders;
CREATE POLICY "public_insert_pending_orders" ON public.orders
FOR INSERT
WITH CHECK (
  -- Allow pending orders from any client (including anonymous)
  status = 'Pendiente' AND
  -- Prevent hijacking by ensuring client_id is either null or matches auth
  (client_id IS NULL OR client_id = auth.uid()) AND
  -- Additional safety: assigned_to must be null for new orders
  assigned_to IS NULL
);

-- 3. More permissive read policy for orders (helps with 401s)
DROP POLICY IF EXISTS "public_read_pending_orders" ON public.orders;
CREATE POLICY "public_read_pending_orders" ON public.orders
FOR SELECT USING (
  -- Allow reading pending orders or own orders
  status = 'Pendiente' OR
  client_id = auth.uid() OR
  assigned_to = auth.uid() OR
  -- Admins and owners can read all
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 4. Make sure collaborator operations work
DROP POLICY IF EXISTS "collaborator_all_on_own_orders" ON public.orders;
CREATE POLICY "collaborator_all_on_own_orders" ON public.orders
FOR ALL USING (
  -- Must be an active collaborator
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  ) AND (
    -- And either the order is assigned to them
    assigned_to = auth.uid() OR
    -- Or it's pending (allowing them to accept it)
    status = 'Pendiente'
  )
) WITH CHECK (
  -- For inserts/updates, must be an active collaborator
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  )
);

-- 5. Fix collaborator self-management
DROP POLICY IF EXISTS "collaborator_self_manage" ON public.collaborators;
CREATE POLICY "collaborator_self_manage" ON public.collaborators
FOR ALL USING (
  -- Collaborators can manage their own profiles
  auth.uid() = id OR
  -- Admins and owners can manage all
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
) WITH CHECK (
  -- Similar check for insert/update
  auth.uid() = id OR
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 6. Add admin insert policy for collaborators (helps with creation)
DROP POLICY IF EXISTS "admin_insert_collaborators" ON public.collaborators;
CREATE POLICY "admin_insert_collaborators" ON public.collaborators
FOR INSERT
WITH CHECK (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 7. Ensure admins can manage profiles
DROP POLICY IF EXISTS "admin_manage_profiles" ON public.profiles;
CREATE POLICY "admin_manage_profiles" ON public.profiles
FOR ALL USING (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 8. Add profile insert for new users
DROP POLICY IF EXISTS "auth_insert_profile" ON public.profiles;
CREATE POLICY "auth_insert_profile" ON public.profiles
FOR INSERT
WITH CHECK (
  -- New users can create their profile
  auth.uid() = id
);

-- Admin/owner opcional (requiere existir en auth.users para no romper FK)
INSERT INTO public.profiles (id, full_name, email, phone, created_at, updated_at)
SELECT
  'a1bd79f0-8a12-40e3-8ee5-d24427dddf71',
  'Carlos López',
  'carloslopez@gmail.com',
  '8090000000',
  NOW(),
  NOW()
WHERE EXISTS (SELECT 1 FROM auth.users WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71')
  AND NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71');

INSERT INTO public.collaborators (id, name, email, phone, matricula, status, created_at)
SELECT
  'a1bd79f0-8a12-40e3-8ee5-d24427dddf71',
  'Carlos López',
  'carloslopez@gmail.com',
  '8090000000',
  '1338547',
  'activo',
  NOW()
WHERE EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71')
  AND NOT EXISTS (SELECT 1 FROM public.collaborators WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71');

UPDATE public.collaborators
SET role = 'administrador'
WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71';

INSERT INTO public.matriculas (user_id, matricula, status, created_at)
SELECT
  'a1bd79f0-8a12-40e3-8ee5-d24427dddf71',
  '1338547',
  'activo',
  NOW()
WHERE EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71')
  AND NOT EXISTS (
    SELECT 1 FROM public.matriculas WHERE user_id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71'
  );

UPDATE public.business
SET owner_user_id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71'
WHERE id = 1
  AND EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71');

-- Script de migración para implementar el código aleatorio de órdenes y corregir client_id
-- Fecha: 2024

-- 1. Eliminar la secuencia antigua que ya no se necesita
DROP SEQUENCE IF EXISTS public.orders_short_id_seq;

-- 2. Crear la nueva función para generar códigos aleatorios en formato ORD-YYYYMMDD-RANDOM
CREATE OR REPLACE FUNCTION public.generate_order_short_id()
RETURNS TEXT AS $$
DECLARE
    fecha_actual TEXT;
    codigo_aleatorio TEXT;
BEGIN
    -- Formato: ORD-YYYYMMDD-RANDOM
    fecha_actual := to_char(current_date, 'YYYYMMDD');
    codigo_aleatorio := upper(substring(md5(random()::text) from 1 for 6));
    RETURN 'ORD-' || fecha_actual || '-' || codigo_aleatorio;
END;
$$ LANGUAGE plpgsql;

-- 3. Crear índice para mejorar el rendimiento de búsquedas por short_id
CREATE INDEX IF NOT EXISTS idx_orders_short_id ON public.orders(short_id);

-- 4. Asegurarse de que la columna client_id existe en la tabla orders
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'orders' 
        AND column_name = 'client_id'
    ) THEN
        ALTER TABLE public.orders ADD COLUMN client_id UUID REFERENCES auth.users(id);
        CREATE INDEX IF NOT EXISTS idx_orders_client_id ON public.orders(client_id);
    END IF;
END $$;

-- Script de migración para implementar el código aleatorio de órdenes y corregir client_id
-- Fecha: 2024

-- 1. Eliminar la secuencia antigua que ya no se necesita
DROP SEQUENCE IF EXISTS public.orders_short_id_seq;

-- 2. Crear la nueva función para generar códigos aleatorios en formato ORD-YYYYMMDD-RANDOM
CREATE OR REPLACE FUNCTION public.generate_order_short_id()
RETURNS TEXT AS $$
DECLARE
    fecha_actual TEXT;
    codigo_aleatorio TEXT;
BEGIN
    -- Formato: ORD-YYYYMMDD-RANDOM
    fecha_actual := to_char(current_date, 'YYYYMMDD');
    codigo_aleatorio := upper(substring(md5(random()::text) from 1 for 6));
    RETURN 'ORD-' || fecha_actual || '-' || codigo_aleatorio;
END;
$$ LANGUAGE plpgsql;

-- 3. Crear índice para mejorar el rendimiento de búsquedas por short_id
CREATE INDEX IF NOT EXISTS idx_orders_short_id ON public.orders(short_id);

-- 4. Asegurarse de que la columna client_id existe en la tabla orders
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'orders' 
        AND column_name = 'client_id'
    ) THEN
        ALTER TABLE public.orders ADD COLUMN client_id UUID REFERENCES auth.users(id);
        CREATE INDEX IF NOT EXISTS idx_orders_client_id ON public.orders(client_id);
    END IF;
END $$;

-- 5. Actualizar las políticas RLS para permitir a los clientes ver sus propias órdenes
-- Eliminado: CREATE POLICY IF NOT EXISTS no es válido en PostgreSQL.
-- La política clients_view_own_orders se crea más abajo mediante DO $$ condicional.

-- 6. Regenerar los códigos de órdenes existentes (opcional - usar con precaución)
-- Comentado por defecto para evitar cambios no deseados en datos existentes
/*
UPDATE public.orders
SET short_id = public.generate_order_short_id()
WHERE true;
*/

-- Nota: El código en cliente.js debe ser actualizado para asignar correctamente el client_id
-- cuando un usuario autenticado crea una orden.
-- 6. Regenerar los códigos de órdenes existentes (opcional - usar con precaución)
-- Comentado por defecto para evitar cambios no deseados en datos existentes
/*
UPDATE public.orders
SET short_id = public.generate_order_short_id()
WHERE true;
*/

-- Nota: El código en cliente.js debe ser actualizado para asignar correctamente el client_id
-- cuando un usuario autenticado crea una orden.

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies 
    WHERE schemaname = 'public' 
    AND tablename = 'orders' 
    AND policyname = 'clients_view_own_orders'
  ) THEN
    EXECUTE '
      CREATE POLICY "clients_view_own_orders"
      ON public.orders
      FOR SELECT
      USING (client_id = auth.uid());
    ';
  END IF;
END $$;

-- Asegura políticas RLS para evitar 401 en inserts con select de órdenes pendientes
-- Ejecutar en Supabase SQL editor

alter table if exists public.orders enable row level security;

-- Permitir INSERT de órdenes en estado Pendiente (anon/autenticados)
drop policy if exists "public_insert_pending_orders" on public.orders;
create policy "public_insert_pending_orders" on public.orders
for insert
with check (
  status = 'Pendiente' and (client_id is null or client_id = auth.uid()) and assigned_to is null
);

-- Permitir SELECT de órdenes pendientes para evitar 401 en retorno de insert
drop policy if exists "public_read_pending_orders" on public.orders;
create policy "public_read_pending_orders" on public.orders
for select using (
  status = 'Pendiente' or client_id = auth.uid() or assigned_to = auth.uid() or public.is_owner(auth.uid()) or public.is_admin(auth.uid())
);

-- Mantener otras políticas comunes
drop policy if exists "clients_read_own_orders" on public.orders;
-- (Eliminado) Duplicado: usar clients_view_own_orders del bloque DO $$.

drop policy if exists "collaborator_read_assigned_orders" on public.orders;
-- (Eliminado) Duplicado: usar orders_select_assigned_collab del bloque DO $$.

drop policy if exists "owner_admin_all_orders" on public.orders;
-- (Eliminado) Duplicado: usar admin_all_orders del bloque DO $$.

-- Nota: El trigger "trg_orders_set_tracking" ya establece tracking_url automáticamente en el backend.




-- Agregar campo push_subscription a orders (para usuarios anónimos o invitados)
ALTER TABLE public.orders
ADD COLUMN IF NOT EXISTS push_subscription JSONB;


-- Agregar columnas para aceptación de órdenes y notificaciones push
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS accepted_by uuid;
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS accepted_at timestamptz;
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS notification_subscription jsonb;
-- Columnas necesarias para asignación y estado del colaborador
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS assigned_to uuid;
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS last_collab_status text;

-- Crear índices para mejor rendimiento
CREATE INDEX IF NOT EXISTS orders_accepted_by_idx ON public.orders (accepted_by);
CREATE INDEX IF NOT EXISTS orders_client_id_idx ON public.orders (client_id);

-- =====================================================
-- MIGRACIÓN: Sistema de IDs Seguros para Orders
-- =====================================================
-- Fecha: $(date)
-- Descripción: Implementa sistema dual de IDs:
--   - supabase_seq_id: Secuencial interno (123, 124, 125...)
--   - client_tracking_id: ID aleatorio único para cliente (32 chars hex)

BEGIN;

-- Extensiones necesarias
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Crear secuencia para supabase_seq_id (empezando en 123)
CREATE SEQUENCE IF NOT EXISTS orders_supabase_seq_id_seq
    START WITH 123
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;

-- =====================================================
-- MIGRACIÓN SEGURA: Agregar client_tracking_id
-- =====================================================

DO $$
BEGIN
  -- Agregar client_tracking_id si no existe
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'orders' AND column_name = 'client_tracking_id'
  ) THEN
    RAISE NOTICE 'Agregando columna client_tracking_id...';
    
    -- Crear la columna
    ALTER TABLE public.orders ADD COLUMN client_tracking_id TEXT;
    
    -- Generar IDs aleatorios únicos para registros existentes
    UPDATE public.orders 
    SET client_tracking_id = encode(gen_random_bytes(16), 'hex')
    WHERE client_tracking_id IS NULL;
    
    -- Hacer la columna NOT NULL y establecer default
    ALTER TABLE public.orders ALTER COLUMN client_tracking_id SET NOT NULL;
    ALTER TABLE public.orders ALTER COLUMN client_tracking_id SET DEFAULT encode(gen_random_bytes(16), 'hex');
    
    RAISE NOTICE 'Columna client_tracking_id agregada exitosamente.';
  ELSE
    RAISE NOTICE 'Columna client_tracking_id ya existe, saltando...';
  END IF;
END $$;

-- =====================================================
-- MIGRACIÓN SEGURA: Agregar supabase_seq_id
-- =====================================================

DO $$
DECLARE
  max_seq_id BIGINT;
BEGIN
  -- Agregar supabase_seq_id si no existe
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'orders' AND column_name = 'supabase_seq_id'
  ) THEN
    RAISE NOTICE 'Agregando columna supabase_seq_id...';
    
    -- Crear la columna
    ALTER TABLE public.orders ADD COLUMN supabase_seq_id BIGINT;
    
    -- Asignar valores secuenciales a registros existentes (empezando en 123)
    WITH numbered_orders AS (
      SELECT id, ROW_NUMBER() OVER (ORDER BY created_at, id) + 122 as seq_num
      FROM public.orders
      WHERE supabase_seq_id IS NULL
    )
    UPDATE public.orders 
    SET supabase_seq_id = numbered_orders.seq_num
    FROM numbered_orders
    WHERE public.orders.id = numbered_orders.id;
    
    -- Obtener el máximo valor asignado
    SELECT COALESCE(MAX(supabase_seq_id), 122) INTO max_seq_id FROM public.orders;
    
    -- Actualizar la secuencia al siguiente valor disponible
    PERFORM setval('orders_supabase_seq_id_seq', max_seq_id + 1, false);
    
    -- Hacer la columna NOT NULL con default de secuencia
    ALTER TABLE public.orders ALTER COLUMN supabase_seq_id SET NOT NULL;
    ALTER TABLE public.orders ALTER COLUMN supabase_seq_id SET DEFAULT nextval('orders_supabase_seq_id_seq');
    
    RAISE NOTICE 'Columna supabase_seq_id agregada. Próximo valor: %', max_seq_id + 1;
  ELSE
    RAISE NOTICE 'Columna supabase_seq_id ya existe, saltando...';
  END IF;
END $$;

-- =====================================================
-- ÍNDICES Y CONSTRAINTS
-- =====================================================

-- Crear índices únicos
CREATE UNIQUE INDEX IF NOT EXISTS idx_orders_client_tracking_id ON public.orders(client_tracking_id);
CREATE UNIQUE INDEX IF NOT EXISTS idx_orders_supabase_seq_id ON public.orders(supabase_seq_id);

-- Agregar constraint de validación para client_tracking_id (32 chars hexadecimal)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'orders_client_tracking_id_hex_check'
  ) THEN
    ALTER TABLE public.orders
    ADD CONSTRAINT orders_client_tracking_id_hex_check
    CHECK (client_tracking_id ~ '^[0-9a-f]{32}$');
    
    RAISE NOTICE 'Constraint de validación hexadecimal agregado.';
  ELSE
    RAISE NOTICE 'Constraint de validación ya existe, saltando...';
  END IF;
END $$;

-- =====================================================
-- VERIFICACIÓN POST-MIGRACIÓN
-- =====================================================

DO $$
DECLARE
  total_orders INTEGER;
  orders_with_tracking_id INTEGER;
  orders_with_seq_id INTEGER;
  min_seq_id BIGINT;
  max_seq_id BIGINT;
BEGIN
  -- Contar registros
  SELECT COUNT(*) INTO total_orders FROM public.orders;
  SELECT COUNT(*) INTO orders_with_tracking_id FROM public.orders WHERE client_tracking_id IS NOT NULL;
  SELECT COUNT(*) INTO orders_with_seq_id FROM public.orders WHERE supabase_seq_id IS NOT NULL;
  
  -- Obtener rango de seq_id
  SELECT MIN(supabase_seq_id), MAX(supabase_seq_id) INTO min_seq_id, max_seq_id FROM public.orders;
  
  -- Mostrar resultados
  RAISE NOTICE '=== VERIFICACIÓN DE MIGRACIÓN ===';
  RAISE NOTICE 'Total de órdenes: %', total_orders;
  RAISE NOTICE 'Órdenes con client_tracking_id: %', orders_with_tracking_id;
  RAISE NOTICE 'Órdenes con supabase_seq_id: %', orders_with_seq_id;
  RAISE NOTICE 'Rango supabase_seq_id: % - %', min_seq_id, max_seq_id;
  
  -- Verificar integridad
  IF total_orders = orders_with_tracking_id AND total_orders = orders_with_seq_id THEN
    RAISE NOTICE '✅ Migración completada exitosamente!';
  ELSE
    RAISE WARNING '⚠️  Posibles inconsistencias detectadas. Revisar manualmente.';
  END IF;
END $$;

COMMIT;

-- =====================================================
-- NOTAS DE USO POST-MIGRACIÓN
-- =====================================================

-- Para mostrar algunos ejemplos de los nuevos IDs:
-- SELECT id, supabase_seq_id, client_tracking_id, status, created_at 
-- FROM public.orders 
-- ORDER BY supabase_seq_id 
-- LIMIT 5;

-- Para buscar por client_tracking_id:
-- SELECT * FROM public.orders WHERE client_tracking_id = 'abc123...';

-- Para buscar por supabase_seq_id:
-- SELECT * FROM public.orders WHERE supabase_seq_id = 123;

-- =====================================================
-- MIGRACIÓN: Sistema de IDs Seguros para Orders
-- =====================================================
-- Fecha: $(date)
-- Descripción: Implementa sistema dual de IDs:
--   - supabase_seq_id: Secuencial interno (123, 124, 125...)
--   - client_tracking_id: ID aleatorio único para cliente (32 chars hex)

BEGIN;

-- Extensiones necesarias
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Crear secuencia para supabase_seq_id (empezando en 123)
CREATE SEQUENCE IF NOT EXISTS orders_supabase_seq_id_seq
    START WITH 123
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;

-- =====================================================
-- MIGRACIÓN SEGURA: Agregar client_tracking_id
-- =====================================================

DO $$
BEGIN
  -- Agregar client_tracking_id si no existe
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'orders' AND column_name = 'client_tracking_id'
  ) THEN
    RAISE NOTICE 'Agregando columna client_tracking_id...';
    
    -- Crear la columna
    ALTER TABLE public.orders ADD COLUMN client_tracking_id TEXT;
    
    -- Generar IDs aleatorios únicos para registros existentes
    UPDATE public.orders 
    SET client_tracking_id = encode(gen_random_bytes(16), 'hex')
    WHERE client_tracking_id IS NULL;
    
    -- Hacer la columna NOT NULL y establecer default
    ALTER TABLE public.orders ALTER COLUMN client_tracking_id SET NOT NULL;
    ALTER TABLE public.orders ALTER COLUMN client_tracking_id SET DEFAULT encode(gen_random_bytes(16), 'hex');
    
    RAISE NOTICE 'Columna client_tracking_id agregada exitosamente.';
  ELSE
    RAISE NOTICE 'Columna client_tracking_id ya existe, saltando...';
  END IF;
END $$;

-- =====================================================
-- MIGRACIÓN SEGURA: Agregar supabase_seq_id
-- =====================================================

DO $$
DECLARE
  max_seq_id BIGINT;
BEGIN
  -- Agregar supabase_seq_id si no existe
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'orders' AND column_name = 'supabase_seq_id'
  ) THEN
    RAISE NOTICE 'Agregando columna supabase_seq_id...';
    
    -- Crear la columna
    ALTER TABLE public.orders ADD COLUMN supabase_seq_id BIGINT;
    
    -- Asignar valores secuenciales a registros existentes (empezando en 123)
    WITH numbered_orders AS (
      SELECT id, ROW_NUMBER() OVER (ORDER BY created_at, id) + 122 as seq_num
      FROM public.orders
      WHERE supabase_seq_id IS NULL
    )
    UPDATE public.orders 
    SET supabase_seq_id = numbered_orders.seq_num
    FROM numbered_orders
    WHERE public.orders.id = numbered_orders.id;
    
    -- Obtener el máximo valor asignado
    SELECT COALESCE(MAX(supabase_seq_id), 122) INTO max_seq_id FROM public.orders;
    
    -- Actualizar la secuencia al siguiente valor disponible
    PERFORM setval('orders_supabase_seq_id_seq', max_seq_id + 1, false);
    
    -- Hacer la columna NOT NULL con default de secuencia
    ALTER TABLE public.orders ALTER COLUMN supabase_seq_id SET NOT NULL;
    ALTER TABLE public.orders ALTER COLUMN supabase_seq_id SET DEFAULT nextval('orders_supabase_seq_id_seq');
    
    RAISE NOTICE 'Columna supabase_seq_id agregada. Próximo valor: %', max_seq_id + 1;
  ELSE
    RAISE NOTICE 'Columna supabase_seq_id ya existe, saltando...';
  END IF;
END $$;

-- =====================================================
-- ÍNDICES Y CONSTRAINTS
-- =====================================================

-- Crear índices únicos
CREATE UNIQUE INDEX IF NOT EXISTS idx_orders_client_tracking_id ON public.orders(client_tracking_id);
CREATE UNIQUE INDEX IF NOT EXISTS idx_orders_supabase_seq_id ON public.orders(supabase_seq_id);

-- Agregar constraint de validación para client_tracking_id (32 chars hexadecimal)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'orders_client_tracking_id_hex_check'
  ) THEN
    ALTER TABLE public.orders
    ADD CONSTRAINT orders_client_tracking_id_hex_check
    CHECK (client_tracking_id ~ '^[0-9a-f]{32}$');
    
    RAISE NOTICE 'Constraint de validación hexadecimal agregado.';
  ELSE
    RAISE NOTICE 'Constraint de validación ya existe, saltando...';
  END IF;
END $$;

-- =====================================================
-- VERIFICACIÓN POST-MIGRACIÓN
-- =====================================================

DO $$
DECLARE
  total_orders INTEGER;
  orders_with_tracking_id INTEGER;
  orders_with_seq_id INTEGER;
  min_seq_id BIGINT;
  max_seq_id BIGINT;
BEGIN
  -- Contar registros
  SELECT COUNT(*) INTO total_orders FROM public.orders;
  SELECT COUNT(*) INTO orders_with_tracking_id FROM public.orders WHERE client_tracking_id IS NOT NULL;
  SELECT COUNT(*) INTO orders_with_seq_id FROM public.orders WHERE supabase_seq_id IS NOT NULL;
  
  -- Obtener rango de seq_id
  SELECT MIN(supabase_seq_id), MAX(supabase_seq_id) INTO min_seq_id, max_seq_id FROM public.orders;
  
  -- Mostrar resultados
  RAISE NOTICE '=== VERIFICACIÓN DE MIGRACIÓN ===';
  RAISE NOTICE 'Total de órdenes: %', total_orders;
  RAISE NOTICE 'Órdenes con client_tracking_id: %', orders_with_tracking_id;
  RAISE NOTICE 'Órdenes con supabase_seq_id: %', orders_with_seq_id;
  RAISE NOTICE 'Rango supabase_seq_id: % - %', min_seq_id, max_seq_id;
  
  -- Verificar integridad
  IF total_orders = orders_with_tracking_id AND total_orders = orders_with_seq_id THEN
    RAISE NOTICE '✅ Migración completada exitosamente!';
  ELSE
    RAISE WARNING '⚠️  Posibles inconsistencias detectadas. Revisar manualmente.';
  END IF;
END $$;

COMMIT;

-- =====================================================
-- NOTAS DE USO POST-MIGRACIÓN
-- =====================================================

-- Para mostrar algunos ejemplos de los nuevos IDs:
-- SELECT id, supabase_seq_id, client_tracking_id, status, created_at 
-- FROM public.orders 
-- ORDER BY supabase_seq_id 
-- LIMIT 5;

-- Para buscar por client_tracking_id:
-- SELECT * FROM public.orders WHERE client_tracking_id = 'abc123...';

-- Para buscar por supabase_seq_id:
-- SELECT * FROM public.orders WHERE supabase_seq_id = 123;


-- =====================================================
-- RPC: accept_order(order_id BIGINT)
-- Actualiza una orden identificada por supabase_seq_id
-- y agrega una entrada inicial al tracking_data
-- =====================================================

BEGIN;

-- Asegurar extensión para funciones de tiempo si se requiere
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Crear función RPC
CREATE OR REPLACE FUNCTION public.accept_order(order_id BIGINT)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  _now TIMESTAMPTZ := NOW();
BEGIN
  -- Intentar actualizar por supabase_seq_id; si existe columna short_id, también permitir coincidencia por short_id
  IF EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'orders' AND column_name = 'short_id'
  ) THEN
    UPDATE public.orders
    SET
      status = 'Aceptada',
      assigned_at = COALESCE(assigned_at, _now),
      tracking_data = (
        COALESCE(tracking_data, '[]'::jsonb)
        || jsonb_build_array(
             jsonb_build_object(
               'status', 'en_camino_recoger',
               'date', _now,
               'description', 'Orden aceptada, en camino a recoger'
             )
           )
      )
    WHERE id = order_id OR supabase_seq_id = order_id OR short_id = order_id::text;
  ELSE
    UPDATE public.orders
    SET
      status = 'Aceptada',
      assigned_at = COALESCE(assigned_at, _now),
      tracking_data = (
        COALESCE(tracking_data, '[]'::jsonb)
        || jsonb_build_array(
             jsonb_build_object(
               'status', 'en_camino_recoger',
               'date', _now,
               'description', 'Orden aceptada, en camino a recoger'
             )
           )
      )
    WHERE id = order_id OR supabase_seq_id = order_id;
  END IF;

  -- Nota: si no existió coincidencia, no se afectarán filas.
END;
$$;

-- Opcional: conceder privilegios de ejecución a roles típicos
GRANT EXECUTE ON FUNCTION public.accept_order(BIGINT) TO anon, authenticated, service_role;

COMMIT;


-- Supabase RPCs y Políticas RLS para TLC
-- Ejecutar este archivo en el editor SQL de Supabase (proyecto remoto)

-- 1) Función: update_order_status
create or replace function public.update_order_status(
  order_id bigint,
  new_status text,
  collaborator_id uuid,
  tracking_entry jsonb,
  extra jsonb
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  updated jsonb;
begin
  update public.orders o
  set
    status = case
      when lower(new_status) = 'entregado' then 'Completada'
      when new_status in ('en_camino_recoger') then 'Aceptada'
      when new_status in ('cargando','en_camino_entregar') then 'En curso'
      else status
    end,
    assigned_to = coalesce(o.assigned_to, collaborator_id),
    assigned_at = case when new_status = 'en_camino_recoger' then now() else assigned_at end,
    completed_at = case when lower(new_status) = 'entregado' then now() else completed_at end,
    last_collab_status = new_status,
    tracking_data = coalesce(o.tracking_data, '[]'::jsonb) || jsonb_build_array(tracking_entry),
    -- aplicar campos extra si vienen (monto/metodo)
    monto_cobrado = coalesce((extra->>'monto_cobrado')::numeric, o.monto_cobrado),
    metodo_pago = coalesce(extra->>'metodo_pago', o.metodo_pago)
  where o.id = order_id
    and (o.assigned_to = collaborator_id or o.assigned_to is null)
  returning to_jsonb(o) into updated;

  if updated is null then
    raise exception 'No autorizado o no encontrada' using errcode = '42501';
  end if;

  return updated;
end;
$$;

grant execute on function public.update_order_status(bigint, text, uuid, jsonb, jsonb) to anon, authenticated;

-- 2) Función: set_order_amount
-- Eliminado: versión antigua de set_order_amount con collaborator_id.

-- 3) Políticas RLS de lectura para orders
-- Nota: las políticas RLS para orders se declaran más abajo
-- en un bloque unificado DO $$ ... $$ idempotente.
-- Evitamos usar CREATE POLICY IF NOT EXISTS (no soportado) y duplicados.

- ========================================================
-- 🚀 Supabase RPCs + Políticas RLS para gestión de órdenes
-- Proyecto: TLC / Logística Carlos López Ortiz
-- ========================================================

-- ===-================================
-- 1️⃣ Función: update_order_status (sin modificar monto_cobrado)
-- ===================================
create or replace function public.update_order_status(
  order_id bigint,
  new_status text,
  collaborator_id uuid,
  tracking_entry jsonb
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  updated jsonb;
begin
  update public.orders o
  set
    status = case
      when lower(new_status) = 'entregado' then 'Completada'
      when new_status in ('en_camino_recoger') then 'Aceptada'
      when new_status in ('cargando','en_camino_entregar') then 'En curso'
      else status
    end,
    assigned_to = coalesce(o.assigned_to, collaborator_id),
    assigned_at = case when new_status = 'en_camino_recoger' then now() else assigned_at end,
    completed_at = case when lower(new_status) = 'entregado' then now() else completed_at end,
    last_collab_status = new_status,
    tracking_data = coalesce(o.tracking_data, '[]'::jsonb) || jsonb_build_array(tracking_entry)
  where o.id = order_id
    and (o.assigned_to = collaborator_id or o.assigned_to is null)
  returning to_jsonb(o) into updated;

  if updated is null then
    raise exception 'No autorizado o no encontrada' using errcode = '42501';
  end if;

  return updated;
end;
$$;

grant execute on function public.update_order_status(bigint, text, uuid, jsonb) to anon, authenticated;

-- ===================================
-- 2️⃣ Función: set_order_amount (solo administrador)
-- ===================================
create or replace function public.set_order_amount_admin(
  order_id bigint,
  amount numeric,
  method text
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  updated jsonb;
begin
  -- ⚠️ Solo usuarios con rol 'service_role' o administradores internos
  if auth.role() != 'service_role' then
    raise exception 'Acceso restringido: solo administradores pueden modificar montos.' using errcode = '42501';
  end if;

  update public.orders o
  set monto_cobrado = amount,
      metodo_pago = method
  where o.id = order_id
  returning to_jsonb(o) into updated;

  if updated is null then
    raise exception 'Orden no encontrada' using errcode = 'P0002';
  end if;

  return updated;
end;
$$;

grant execute on function public.set_order_amount_admin(bigint, numeric, text) to service_role;

-- ===================================
-- 3️⃣ Políticas RLS para la tabla orders
-- ===================================
-- RLS para orders se habilita dentro del bloque DO $$ unificado.

-- 🟢 Lectura para colaboradores autenticados asignados
-- Se gestiona en el bloque DO $$ unificado más abajo.

-- 🟢 Lectura para clientes autenticados (propietarios de la orden)
-- Se gestiona en el bloque DO $$ unificado más abajo.

-- 🟢 Lectura pública (seguimiento anónimo)
-- Eliminado: lectura pública masiva en orders (riesgo de privacidad)

-- 🟢 Inserción pública (clientes pueden crear pedidos)
-- Eliminado: inserción pública irrestricta; se reemplazará por RPC controlada.

-- ❌ Bloquear updates directos desde el cliente o colaborador
-- Eliminado: política de actualización directa; controlaremos updates vía admin y RPC.

-- ✅ Solo el administrador (service_role) puede actualizar campos financieros
-- Se unificará en un bloque DO $$ ... $$ de RLS coherente más abajo.

-- ========================================================
-- Tabla de clientes para solicitudes sin usuario autenticado

-- Bloque RLS unificado y condicional para public.orders
do $$
begin
  -- Asegurar RLS habilitada
  perform 1;
  begin
    alter table public.orders enable row level security;
  exception when others then
    -- ignorar si ya está habilitado
    perform 1;
  end;

  -- Clientes autenticados ven sus propias órdenes
  if not exists (
    select 1 from pg_policies 
    where schemaname = 'public' and tablename = 'orders' and polname = 'clients_view_own_orders'
  ) then
    create policy clients_view_own_orders
      on public.orders
      for select
      to authenticated
      using (client_id = auth.uid());
  end if;

  -- Colaborador ve órdenes asignadas a su usuario
  if not exists (
    select 1 from pg_policies 
    where schemaname = 'public' and tablename = 'orders' and polname = 'orders_select_assigned_collab'
  ) then
    create policy orders_select_assigned_collab
      on public.orders
      for select
      to authenticated
      using (assigned_to = auth.uid());
  end if;

  -- Admin/Owner lectura/escritura total
  if not exists (
    select 1 from pg_policies 
    where schemaname = 'public' and tablename = 'orders' and polname = 'admin_all_orders'
  ) then
    create policy admin_all_orders
      on public.orders
      for all
      to authenticated
      using (public.is_admin(auth.uid()) or public.is_owner(auth.uid()))
      with check (public.is_admin(auth.uid()) or public.is_owner(auth.uid()));
  end if;
end $$;

create table if not exists public.clients (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  phone text,
  email text,
  created_at timestamptz not null default now()
);

-- Añadir columna en orders para referenciar contacto de cliente
do $$ begin
  if not exists (
    select 1 from information_schema.columns 
    where table_schema = 'public' and table_name = 'orders' and column_name = 'client_contact_id'
  ) then
    alter table public.orders add column client_contact_id uuid;
  end if;
end $$;

-- FK hacia clients.id
do $$ begin
  if not exists (
    select 1 from pg_constraint where conname = 'orders_client_contact_id_fkey'
  ) then
    alter table public.orders
      add constraint orders_client_contact_id_fkey
      foreign key (client_contact_id)
      references public.clients(id)
      on delete set null;
  end if;
end $$;

-- RLS para clients (permitir insert/select a anon y authenticated)
alter table public.clients enable row level security;

do $$ begin
  if not exists (
    select 1 from pg_policies where schemaname = 'public' and tablename = 'clients' and policyname = 'clients_insert_any'
  ) then
    create policy clients_insert_any on public.clients
      for insert to anon, authenticated
      with check (true);
  end if;
end $$;

do $$ begin
  if not exists (
    select 1 from pg_policies where schemaname = 'public' and tablename = 'clients' and policyname = 'clients_select_any'
  ) then
    create policy clients_select_any on public.clients
      for select to anon, authenticated
      using (true);
  end if;
end $$;


-- RPC: public.create_order_with_contact
-- Inserta una orden creando contacto en public.clients si no hay usuario autenticado
-- Devuelve la fila completa de public.orders

CREATE OR REPLACE FUNCTION public.create_order_with_contact(order_payload jsonb)
RETURNS public.orders
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_client_id uuid := (SELECT auth.uid());
  v_contact_id uuid;
  v_order public.orders;
BEGIN
  -- Si no hay usuario autenticado, crear contacto anónimo y usar push_subscription
  IF v_client_id IS NULL THEN
    INSERT INTO public.clients(name, phone, email)
    VALUES (
      NULLIF(order_payload->>'name',''),
      NULLIF(order_payload->>'phone',''),
      NULLIF(order_payload->>'email','')
    )
    RETURNING id INTO v_contact_id;

    INSERT INTO public.orders (
      name, phone, email, rnc, empresa,
      service_id, vehicle_id, service_questions,
      pickup, delivery,
      origin_coords, destination_coords,
      date, time,
      status, estimated_price,
      tracking_data,
      client_contact_id,
      push_subscription
    ) VALUES (
      NULLIF(order_payload->>'name',''),
      NULLIF(order_payload->>'phone',''),
      NULLIF(order_payload->>'email',''),
      NULLIF(order_payload->>'rnc',''),
      NULLIF(order_payload->>'empresa',''),
      NULLIF(order_payload->>'service_id','')::int,
      NULLIF(order_payload->>'vehicle_id','')::int,
      order_payload->'service_questions',
      order_payload->>'pickup',
      order_payload->>'delivery',
      order_payload->'origin_coords',
      order_payload->'destination_coords',
      order_payload->>'date',
      order_payload->>'time',
      COALESCE(order_payload->>'status','Pendiente'),
      order_payload->>'estimated_price',
      order_payload->'tracking_data',
      v_contact_id,
      order_payload->'push_subscription'
    )
    RETURNING * INTO v_order;
  ELSE
    -- Usuario autenticado: usar client_id y no client_contact_id
    INSERT INTO public.orders (
      name, phone, email, rnc, empresa,
      service_id, vehicle_id, service_questions,
      pickup, delivery,
      origin_coords, destination_coords,
      date, time,
      status, estimated_price,
      tracking_data,
      client_id
    ) VALUES (
      NULLIF(order_payload->>'name',''),
      NULLIF(order_payload->>'phone',''),
      NULLIF(order_payload->>'email',''),
      NULLIF(order_payload->>'rnc',''),
      NULLIF(order_payload->>'empresa',''),
      NULLIF(order_payload->>'service_id','')::int,
      NULLIF(order_payload->>'vehicle_id','')::int,
      order_payload->'service_questions',
      order_payload->>'pickup',
      order_payload->>'delivery',
      order_payload->'origin_coords',
      order_payload->'destination_coords',
      order_payload->>'date',
      order_payload->>'time',
      COALESCE(order_payload->>'status','Pendiente'),
      order_payload->>'estimated_price',
      order_payload->'tracking_data',
      v_client_id
    )
    RETURNING * INTO v_order;
  END IF;

  RETURN v_order;
END;
$$;

GRANT EXECUTE ON FUNCTION public.create_order_with_contact(jsonb) TO anon;
GRANT EXECUTE ON FUNCTION public.create_order_with_contact(jsonb) TO authenticated;

-- RPC pública segura: seguimiento por client_tracking_id
create or replace function public.get_order_tracking_public(tracking_id text)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  payload jsonb;
begin
  -- Retorna únicamente columnas necesarias para seguimiento
  select to_jsonb(row)
  into payload
  from (
    select
      o.id,
      o.short_id,
      o.client_tracking_id,
      o.status,
      o.origin_coords,
      o.destination_coords,
      o.pickup,
      o.delivery,
      o.tracking_data,
      o.created_at,
      o.updated_at
    from public.orders o
    where o.client_tracking_id = tracking_id
    limit 1
  ) row;

  if payload is null then
    raise exception 'Orden no encontrada' using errcode = 'P0002';
  end if;

  return payload;
end;
$$;

revoke all on function public.get_order_tracking_public(text) from public;
grant execute on function public.get_order_tracking_public(text) to anon, authenticated;


-- View: public.orders_with_client
-- Unifica los datos del cliente desde orders, profiles y clients
-- y expone columnas auxiliares para nombre de servicio, vehículo
-- y nombre del colaborador que completó la orden.

CREATE OR REPLACE VIEW public.orders_with_client AS
SELECT
  o.*,
  COALESCE(o.name, p.full_name) AS client_name,
  COALESCE(o.phone, p.phone) AS client_phone,
  COALESCE(o.email, p.email) AS client_email,
  s.name AS service_name,
  v.name AS vehicle_name,
  cb.full_name AS completed_by_full_name
FROM public.orders o
LEFT JOIN public.profiles p ON p.id = o.client_id
LEFT JOIN public.services s ON s.id = o.service_id
LEFT JOIN public.vehicles v ON v.id = o.vehicle_id
LEFT JOIN public.profiles cb ON cb.id = o.completed_by;

GRANT SELECT ON public.orders_with_client TO anon;
GRANT SELECT ON public.orders_with_client TO authenticated;

-- push_subscription ya se agrega arriba con ALTER TABLE ... IF NOT EXISTS; se elimina duplicado.


-- ==========================================================
-- ✅ Function: public.set_order_amount
-- ----------------------------------------------------------
-- Purpose:
--  Actualiza monto_cobrado y metodo_pago de una orden.
--  - Administradores pueden editar cualquier orden.
--  - Colaboradores solo las órdenes asignadas a ellos.
--  - Ejecuta con SECURITY DEFINER para bypass RLS de forma segura.
-- ==========================================================

CREATE OR REPLACE FUNCTION public.set_order_amount(
  order_id integer,
  amount numeric,
  method text,
  collaborator_id uuid DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_order record;
  user_role text;
  is_admin boolean;
BEGIN
  -- 1️⃣ Verificar rol del usuario autenticado
  SELECT role INTO user_role
  FROM public.profiles
  WHERE id = auth.uid();

  is_admin := (user_role = 'admin');

  -- 2️⃣ Actualización según rol
  IF is_admin THEN
    UPDATE public.orders
    SET 
      monto_cobrado = amount,
      metodo_pago = NULLIF(method, '')
    WHERE id = order_id
    RETURNING id, short_id, monto_cobrado, metodo_pago
    INTO v_order;
  ELSE
    UPDATE public.orders
    SET 
      monto_cobrado = amount,
      metodo_pago = NULLIF(method, '')
    WHERE id = order_id
      AND (assigned_to = collaborator_id OR assigned_to = auth.uid())
    RETURNING id, short_id, monto_cobrado, metodo_pago
    INTO v_order;
  END IF;

  -- 3️⃣ Validar resultado
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Orden no encontrada o sin autorización' 
      USING errcode = 'P0002';
  END IF;

  -- 4️⃣ Retornar objeto JSON con los campos actualizados
  RETURN json_build_object(
    'id', v_order.id,
    'short_id', v_order.short_id,
    'monto_cobrado', v_order.monto_cobrado,
    'metodo_pago', v_order.metodo_pago
  );
END;
$$;

-- 🔒 Unificar: función admin-only para actualizar montos
create or replace function public.set_order_amount(
  order_id bigint,
  amount numeric,
  method text
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  updated jsonb;
begin
  -- Solo administradores (según public.is_admin) o service_role
  if not (public.is_admin(auth.uid()) or auth.role() = 'service_role') then
    raise exception 'Acceso restringido: solo el administrador puede modificar montos.' using errcode = '42501';
  end if;

  update public.orders o
  set
    monto_cobrado = amount,
    metodo_pago = nullif(method, '')
  where o.id = order_id
  returning to_jsonb(o) into updated;

  if updated is null then
    raise exception 'Orden no encontrada' using errcode = 'P0002';
  end if;

  return updated;
end;
$$;

revoke all on function public.set_order_amount(bigint, numeric, text) from public;
grant execute on function public.set_order_amount(bigint, numeric, text) to authenticated, service_role;


create or replace function public.update_order_status(
  order_id bigint,
  new_status text,
  collaborator_id uuid,
  tracking_entry jsonb
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  updated jsonb;
begin
  update public.orders o
  set
    status = case
      when lower(new_status) = 'entregado' then 'Completada'
      when new_status in ('en_camino_recoger') then 'Aceptada'
      when new_status in ('cargando','en_camino_entregar') then 'En curso'
      else status
    end,
    assigned_to = coalesce(o.assigned_to, collaborator_id),
    assigned_at = case when new_status = 'en_camino_recoger' then now() else assigned_at end,
    completed_at = case when lower(new_status) = 'entregado' then now() else completed_at end,
    completed_by = case when lower(new_status) = 'entregado' then collaborator_id else completed_by end,
    last_collab_status = new_status,
    tracking_data = coalesce(o.tracking_data, '[]'::jsonb) || jsonb_build_array(tracking_entry)
  where o.id = order_id
    and (o.assigned_to = collaborator_id or o.assigned_to is null)
  returning to_jsonb(o) into updated;

  if updated is null then
    raise exception 'No autorizado o no encontrada' using errcode = '42501';
  end if;

  return updated;
end;
$$;

grant execute on function public.update_order_status(bigint, text, uuid, jsonb) to anon, authenticated;


-- (LIMPIEZA LEGACY)
-- Se elimina la vista orders_with_client y la política insegura
-- "Clientes pueden crear órdenes". La inserción pública se controla
-- por la política "public_insert_pending_orders" con estado seguro.

-- 🔹 2. Evitar que usuarios anónimos lean todas las órdenes
-- Política correcta: solo admins/owners pueden leer todas las órdenes
drop policy if exists "Solo lectura para admins" on public.orders;
create policy "Solo lectura para admins"
on public.orders
for select
using (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);


-- Tabla de rendimiento del colaborador
-- Vinculada a public.collaborators y protegida por RLS

create extension if not exists pgcrypto;

create table if not exists public.collaborator_performance (
  id uuid primary key default gen_random_uuid(),
  collaborator_id uuid not null references public.collaborators(id) on delete cascade,
  period_start date not null,
  period_end date not null,
  jobs_completed int not null default 0,
  jobs_cancelled int not null default 0,
  avg_completion_minutes numeric(10,2),
  avg_rating numeric(3,2),
  on_time_rate numeric(5,2),
  total_distance_km numeric(10,2),
  revenue numeric(12,2),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint collaborator_performance_period_unique unique (collaborator_id, period_start, period_end)
);

-- Índices para consultas eficientes
create index if not exists collaborator_performance_collaborator_idx on public.collaborator_performance(collaborator_id);
create index if not exists collaborator_performance_period_start_idx on public.collaborator_performance(period_start);
create index if not exists collaborator_performance_period_end_idx on public.collaborator_performance(period_end);

-- Activar RLS
alter table public.collaborator_performance enable row level security;

-- Políticas: colaboradores leen su propio rendimiento; admins/owners gestionan todo
drop policy if exists "collaborator_read_own_performance" on public.collaborator_performance;
create policy "collaborator_read_own_performance" on public.collaborator_performance
  for select using (collaborator_id = auth.uid());

drop policy if exists "admin_manage_performance" on public.collaborator_performance;
create policy "admin_manage_performance" on public.collaborator_performance
  for all using (public.is_owner(auth.uid()) or public.is_admin(auth.uid()))
  with check (public.is_owner(auth.uid()) or public.is_admin(auth.uid()));

-- Trigger para mantener updated_at
create or replace function public.set_updated_at_collab_perf()
returns trigger as $$
begin
  new.updated_at := now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists trg_set_updated_at_collab_perf on public.collaborator_performance;
create trigger trg_set_updated_at_collab_perf
before update on public.collaborator_performance
for each row execute function public.set_updated_at_collab_perf();

comment on table public.collaborator_performance is 'Métricas de rendimiento por período para colaboradores.';
comment on column public.collaborator_performance.avg_completion_minutes is 'Tiempo promedio de completitud en minutos.';
comment on column public.collaborator_performance.on_time_rate is 'Porcentaje de entregas a tiempo (0-100).';


-- Migration: device_bindings, profile_changes, client_logs

-- Table: device_bindings
create table if not exists public.device_bindings (
  id uuid primary key default gen_random_uuid(),
  device_id text not null unique,
  user_id uuid not null,
  bound_at timestamptz not null default now(),
  last_seen timestamptz
);
alter table public.device_bindings enable row level security;

-- Table: profile_changes (auditoría de cambios de perfiles)
create table if not exists public.profile_changes (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null,
  editor_id uuid,
  changed_fields jsonb not null,
  created_at timestamptz not null default now()
);
alter table public.profile_changes enable row level security;

-- Table: client_logs (logs cliente opcionales)
create table if not exists public.client_logs (
  id uuid primary key default gen_random_uuid(),
  level text,
  message text,
  stack text,
  url text,
  user_id uuid,
  created_at timestamptz not null default now()
);
alter table public.client_logs enable row level security;

-- Nota: Las políticas RLS deben definirse según roles del proyecto.
-- En esta migración se habilita RLS pero no se crean políticas, por lo que el acceso
-- queda restringido por defecto (solo service role). Añade políticas en supabase/policies/rls_policies.sql.

-- Asegurar integridad referencial en tablas nuevas (agregar FKs si faltan)
DO $$
BEGIN
  -- device_bindings.user_id -> profiles(id)
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'device_bindings_user_fk'
  ) THEN
    ALTER TABLE public.device_bindings
      ADD CONSTRAINT device_bindings_user_fk
      FOREIGN KEY (user_id)
      REFERENCES public.profiles(id)
      ON DELETE CASCADE;
  END IF;

  -- profile_changes.user_id -> profiles(id)
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'profile_changes_user_fk'
  ) THEN
    ALTER TABLE public.profile_changes
      ADD CONSTRAINT profile_changes_user_fk
      FOREIGN KEY (user_id)
      REFERENCES public.profiles(id)
      ON DELETE CASCADE;
  END IF;

  -- profile_changes.editor_id -> profiles(id)
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'profile_changes_editor_fk'
  ) THEN
    ALTER TABLE public.profile_changes
      ADD CONSTRAINT profile_changes_editor_fk
      FOREIGN KEY (editor_id)
      REFERENCES public.profiles(id)
      ON DELETE SET NULL;
  END IF;

  -- client_logs.user_id -> profiles(id)
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'client_logs_user_fk'
  ) THEN
    ALTER TABLE public.client_logs
      ADD CONSTRAINT client_logs_user_fk
      FOREIGN KEY (user_id)
      REFERENCES public.profiles(id)
      ON DELETE SET NULL;
  END IF;
END $$;


-- RLS policies for collaborators and orders

-- Collaborators table
alter table public.collaborators enable row level security;

create policy "collab self select" on public.collaborators
for select using (id = auth.uid());

create policy "admin select all" on public.collaborators
for select using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

create policy "admin insert" on public.collaborators
for insert with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

create policy "admin update" on public.collaborators
for update using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

create policy "admin delete" on public.collaborators
for delete using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Orders table
alter table public.orders enable row level security;

create policy "admin select orders" on public.orders
for select using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

create policy "collaborator select assigned" on public.orders
for select using (assigned_to = auth.uid());

create policy "admin update orders" on public.orders
for update using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

create policy "collaborator update own assigned" on public.orders
for update using (assigned_to = auth.uid())
with check (assigned_to = auth.uid());

create policy "admin insert orders" on public.orders
for insert with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

create policy "admin delete orders" on public.orders
for delete using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Device Bindings table
alter table public.device_bindings enable row level security;

-- Allow admins full access
create policy "admin select device_bindings" on public.device_bindings
for select using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

create policy "admin insert device_bindings" on public.device_bindings
for insert with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

create policy "admin update device_bindings" on public.device_bindings
for update using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

create policy "admin delete device_bindings" on public.device_bindings
for delete using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Allow regular users to view their own device bindings
create policy "user select own device_bindings" on public.device_bindings
for select using (user_id = auth.uid());

-- Allow users to create and delete their own device bindings (auto-bind/unbind)
DROP POLICY IF EXISTS "user insert own device_bindings" ON public.device_bindings;
CREATE POLICY "user insert own device_bindings" ON public.device_bindings
FOR INSERT WITH CHECK (user_id = auth.uid());

DROP POLICY IF EXISTS "user delete own device_bindings" ON public.device_bindings;
CREATE POLICY "user delete own device_bindings" ON public.device_bindings
FOR DELETE USING (user_id = auth.uid());

-- Profile Changes table
alter table public.profile_changes enable row level security;

create policy "admin select profile_changes" on public.profile_changes
for select using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

create policy "admin insert profile_changes" on public.profile_changes
for insert with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

create policy "admin update profile_changes" on public.profile_changes
for update using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

create policy "admin delete profile_changes" on public.profile_changes
for delete using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Allow users to view their own profile changes
create policy "user select own profile_changes" on public.profile_changes
for select using (user_id = auth.uid());

-- Client Logs table
alter table public.client_logs enable row level security;

create policy "admin select client_logs" on public.client_logs
for select using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Allow authenticated users to insert their own logs
create policy "user insert own client_logs" on public.client_logs
for insert with check (user_id = auth.uid());

-- Allow users to select their own logs
create policy "user select own client_logs" on public.client_logs
for select using (user_id = auth.uid());