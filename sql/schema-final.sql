-- =============================================================
--        ESQUEMA COMPLETO TLC (Versión lista para Supabase)
-- =============================================================
-- Incluye:
-- - Tablas base (vehículos, servicios)
-- - Perfiles, colaboradores y matrículas
-- - Órdenes con códigos aleatorios, notificaciones y suscripciones
-- - Configuración del negocio con RNC y dueño
-- - Políticas RLS seguras y triggers automáticos
-- =============================================================

-- --------------------------------------------------------------
-- 1. EXTENSIONES
-- --------------------------------------------------------------
create extension if not exists pgcrypto;

-- --------------------------------------------------------------
-- 2. TABLAS CATÁLOGO: VEHÍCULOS Y SERVICIOS
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.vehicles CASCADE;
CREATE TABLE public.vehicles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    image_url TEXT,
    is_active BOOLEAN DEFAULT true NOT NULL
);
COMMENT ON TABLE public.vehicles IS 'Catálogo de vehículos disponibles para los servicios.';

DROP TABLE IF EXISTS public.services CASCADE;
CREATE TABLE public.services (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    image_url TEXT,
    is_active BOOLEAN DEFAULT true NOT NULL,
    display_order INT
);
COMMENT ON TABLE public.services IS 'Catálogo de los servicios ofrecidos por el negocio.';

-- --------------------------------------------------------------
-- 3. USUARIOS Y COLABORADORES
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.profiles CASCADE;
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name TEXT,
    email TEXT,
    phone TEXT,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);
COMMENT ON TABLE public.profiles IS 'Datos públicos del usuario (sin roles, vinculados a auth.users).';

DROP TABLE IF EXISTS public.collaborators CASCADE;
CREATE TABLE public.collaborators (
    id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    name TEXT,
    email TEXT,
    phone TEXT,
    matricula TEXT,
    status TEXT DEFAULT 'activo' NOT NULL,
    role TEXT DEFAULT 'colaborador' NOT NULL CHECK (lower(role) IN ('administrador','colaborador')),
    push_subscription JSONB,
    notes TEXT,
    updated_at timestamptz not null default now()
);
COMMENT ON TABLE public.collaborators IS 'Datos operativos de colaboradores.';

DROP TABLE IF EXISTS public.matriculas CASCADE;
CREATE TABLE public.matriculas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    matricula TEXT NOT NULL,
    status TEXT DEFAULT 'activo' NOT NULL
);
COMMENT ON TABLE public.matriculas IS 'Matrículas/placas de los colaboradores.';

CREATE INDEX IF NOT EXISTS idx_matriculas_user_id ON public.matriculas(user_id);
CREATE INDEX IF NOT EXISTS idx_collaborators_status ON public.collaborators(status);
CREATE INDEX IF NOT EXISTS idx_collaborators_role ON public.collaborators(role);
CREATE INDEX IF NOT EXISTS idx_collaborators_email ON public.collaborators(email);
CREATE INDEX IF NOT EXISTS idx_profiles_email ON public.profiles(email);

-- Trigger para updated_at
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS trigger AS $$
BEGIN
  new.updated_at = now();
  RETURN new;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_profiles_set_updated ON public.profiles;
CREATE TRIGGER trg_profiles_set_updated
BEFORE UPDATE ON public.profiles
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

DROP TRIGGER IF EXISTS trg_collaborators_touch_updated ON public.collaborators;
CREATE TRIGGER trg_collaborators_touch_updated
BEFORE UPDATE ON public.collaborators
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

-- --------------------------------------------------------------
-- 4. CONFIGURACIÓN DEL NEGOCIO
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.business CASCADE;
CREATE TABLE public.business (
  id integer primary key default 1,
  business_name text,
  address text,
  phone text,
  email text,
  rnc text CHECK (rnc ~ '^[0-9]{9,11}$' OR rnc IS NULL),
  quotation_rates jsonb,
  owner_user_id uuid references public.profiles(id) on delete set null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

COMMENT ON TABLE public.business IS 'Configuración general del negocio.';

CREATE INDEX IF NOT EXISTS idx_business_owner ON public.business(owner_user_id);
CREATE INDEX IF NOT EXISTS idx_business_rnc ON public.business(rnc);

-- Trigger updated_at
CREATE OR REPLACE FUNCTION public.touch_updated_at()
RETURNS trigger AS $$
BEGIN
  new.updated_at = now();
  RETURN new;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_business_touch_updated ON public.business;
CREATE TRIGGER trg_business_touch_updated
BEFORE UPDATE ON public.business
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

-- Seed inicial
INSERT INTO public.business (id, business_name, address, phone, email)
VALUES (1, 'Mi Negocio', '', '', '')
ON CONFLICT (id) DO NOTHING;

-- --------------------------------------------------------------
-- 4.b COMPATIBILIDAD: business_settings (para proyectos antiguos)
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.business_settings CASCADE;
CREATE TABLE public.business_settings (
  id integer primary key default 1,
  business_name text,
  address text,
  phone text,
  email text,
  rnc text,
  quotation_rates jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

COMMENT ON TABLE public.business_settings IS 'Tabla de compatibilidad para configuraciones del negocio; preferir public.business.';

-- Trigger updated_at (reutiliza la función touch_updated_at)
DROP TRIGGER IF EXISTS trg_business_settings_touch_updated ON public.business_settings;
CREATE TRIGGER trg_business_settings_touch_updated
BEFORE UPDATE ON public.business_settings
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

-- Consistencia de RNC
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'business_settings_rnc_check'
  ) THEN
    ALTER TABLE public.business_settings
      ADD CONSTRAINT business_settings_rnc_check
      CHECK (rnc ~ '^[0-9]{9,11}$' OR rnc IS NULL);
  END IF;
END $$;

-- Seed inicial de compatibilidad
INSERT INTO public.business_settings (id, business_name, address, phone, email)
VALUES (1, 'Mi Negocio', '', '', '')
ON CONFLICT (id) DO NOTHING;

-- --------------------------------------------------------------
-- 5.a FUNCIONES DE ROL (helpers)
-- --------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.is_owner(uid uuid)
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS(
    SELECT 1 FROM public.business b WHERE b.owner_user_id = uid
  );
$$;

CREATE OR REPLACE FUNCTION public.is_admin(uid uuid)
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS(
    SELECT 1 FROM public.collaborators c
    WHERE c.id = uid AND lower(coalesce(c.role, 'colaborador')) = 'administrador'
  );
$$;

-- --------------------------------------------------------------
-- 5. ÓRDENES Y NOTIFICACIONES
-- --------------------------------------------------------------
-- Ya no necesitamos la secuencia para los IDs cortos
DROP SEQUENCE IF EXISTS public.orders_short_id_seq;

CREATE OR REPLACE FUNCTION public.generate_order_short_id()
RETURNS TEXT AS $$
DECLARE
    random_part TEXT;
    date_part TEXT;
BEGIN
    -- Generar parte aleatoria (equivalente a Math.random().toString(36).substring(2, 8).toUpperCase())
    random_part := upper(substring(md5(random()::text) from 1 for 6));
    
    -- Obtener fecha actual en formato YYYYMMDD
    date_part := to_char(current_date, 'YYYYMMDD');
    
    -- Combinar en formato ORD-YYYYMMDD-RANDOM
    RETURN 'ORD-' || date_part || '-' || random_part;
END;
$$ LANGUAGE plpgsql;

DROP TABLE IF EXISTS public.orders CASCADE;
CREATE TABLE public.orders (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    short_id TEXT UNIQUE DEFAULT public.generate_order_short_id(),
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    client_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    phone TEXT NOT NULL,
    email TEXT,
    rnc TEXT,
    empresa TEXT,
    service_id BIGINT REFERENCES public.services(id) ON DELETE SET NULL,
    vehicle_id BIGINT REFERENCES public.vehicles(id) ON DELETE SET NULL,
    service_questions JSONB,
    pickup TEXT,
    delivery TEXT,
    origin_coords JSONB,
    destination_coords JSONB,
    "date" DATE,
    "time" TIME,
    status TEXT DEFAULT 'Pendiente' NOT NULL,
    assigned_to UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    assigned_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    completed_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    evidence_photos JSONB,
    rating JSONB,
    estimated_price TEXT DEFAULT 'Por confirmar',
    monto_cobrado NUMERIC,
    metodo_pago TEXT,
    tracking_data JSONB,
    tracking_url TEXT,
    updated_at timestamptz not null default now()
);

CREATE INDEX IF NOT EXISTS idx_orders_status ON public.orders(status);
CREATE INDEX IF NOT EXISTS idx_orders_date ON public.orders("date");
CREATE INDEX IF NOT EXISTS idx_orders_assigned_to ON public.orders(assigned_to);
CREATE INDEX IF NOT EXISTS idx_orders_client_id ON public.orders(client_id);

-- Constraint de estado permitido
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'orders_status_check'
  ) THEN
    ALTER TABLE public.orders
      ADD CONSTRAINT orders_status_check
      CHECK (status IN ('Pendiente','Aceptada','En curso','Completada','Cancelada'));
  END IF;
END $$;

-- Trigger: setear tracking_url automáticamente al crear la orden
CREATE OR REPLACE FUNCTION public.set_order_tracking_url()
RETURNS trigger AS $$
BEGIN
  IF new.tracking_url IS NULL OR new.tracking_url = '' THEN
    new.tracking_url := '/seguimiento.html?codigo=' || coalesce(new.short_id::text, new.id::text);
  END IF;
  RETURN new;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_orders_set_tracking ON public.orders;
CREATE TRIGGER trg_orders_set_tracking
BEFORE INSERT ON public.orders
FOR EACH ROW EXECUTE FUNCTION public.set_order_tracking_url();

-- Trigger updated_at para orders
DROP TRIGGER IF EXISTS trg_orders_touch_updated ON public.orders;
CREATE TRIGGER trg_orders_touch_updated
BEFORE UPDATE ON public.orders
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

-- Notificaciones
DROP TABLE IF EXISTS public.notifications CASCADE;
CREATE TABLE public.notifications (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade,
  title text,
  body text,
  data jsonb,
  created_at timestamptz not null default now(),
  read_at timestamptz
);
CREATE INDEX IF NOT EXISTS idx_notifications_user ON public.notifications(user_id);

-- Suscripciones push
DROP TABLE IF EXISTS public.push_subscriptions CASCADE;
CREATE TABLE public.push_subscriptions (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade,
  endpoint text not null,
  keys jsonb not null,
  created_at timestamptz not null default now()
);
CREATE INDEX IF NOT EXISTS idx_push_subscriptions_user ON public.push_subscriptions(user_id);

-- --------------------------------------------------------------
-- 6. POLÍTICAS RLS (SEGURIDAD)
-- --------------------------------------------------------------
ALTER TABLE public.vehicles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.services ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.collaborators ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.matriculas ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.business ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.business_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.push_subscriptions ENABLE ROW LEVEL SECURITY;

-- Limpieza previa de políticas antiguas
DROP POLICY IF EXISTS "public_read_vehicles" ON public.vehicles;
DROP POLICY IF EXISTS "public_read_services" ON public.services;
DROP POLICY IF EXISTS "owner_all_access_vehicles" ON public.vehicles;
DROP POLICY IF EXISTS "owner_all_access_services" ON public.services;
DROP POLICY IF EXISTS "public_read_profiles" ON public.profiles;
DROP POLICY IF EXISTS "users_update_own_profile" ON public.profiles;
DROP POLICY IF EXISTS "public_insert_pending_orders" ON public.orders;
DROP POLICY IF EXISTS "clients_read_own_orders" ON public.orders;
DROP POLICY IF EXISTS "collaborator_read_pending_orders" ON public.orders;
DROP POLICY IF EXISTS "collaborator_read_assigned_orders" ON public.orders;
DROP POLICY IF EXISTS "collaborator_update_own_orders" ON public.orders;
DROP POLICY IF EXISTS "owner_admin_all_orders" ON public.orders;
DROP POLICY IF EXISTS "collaborator_self_select" ON public.collaborators;
DROP POLICY IF EXISTS "collaborator_self_update" ON public.collaborators;
DROP POLICY IF EXISTS "owner_manage_collaborators" ON public.collaborators;
DROP POLICY IF EXISTS "admin_manage_collaborators" ON public.collaborators;
DROP POLICY IF EXISTS "collaborator_read_own_matriculas" ON public.matriculas;
DROP POLICY IF EXISTS "owner_manage_matriculas" ON public.matriculas;
DROP POLICY IF EXISTS "admin_manage_matriculas" ON public.matriculas;
DROP POLICY IF EXISTS "owner_full_access_business" ON public.business;
DROP POLICY IF EXISTS "owner_full_access_business_settings" ON public.business_settings;
DROP POLICY IF EXISTS "user_manage_own_push_subscriptions" ON public.push_subscriptions;
DROP POLICY IF EXISTS "user_read_own_notifications" ON public.notifications;
DROP POLICY IF EXISTS "user_manage_own_notifications" ON public.notifications;

-- Vehículos y servicios
CREATE POLICY "public_read_vehicles" ON public.vehicles FOR SELECT USING (true);
CREATE POLICY "public_read_services" ON public.services FOR SELECT USING (true);
CREATE POLICY "owner_all_access_vehicles" ON public.vehicles FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);
CREATE POLICY "owner_all_access_services" ON public.services FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Profiles
CREATE POLICY "public_read_profiles" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "users_update_own_profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Orders
-- Importante para evitar el error RLS en INSERT desde cliente anónimo o autenticado sin client_id
-- Permitimos insertar órdenes en estado Pendiente, asignando client_id NULL o igual a auth.uid()
CREATE POLICY "public_insert_pending_orders" ON public.orders
FOR INSERT
WITH CHECK (
  status = 'Pendiente' AND (client_id IS NULL OR client_id = auth.uid())
);

CREATE POLICY "clients_read_own_orders" ON public.orders FOR SELECT USING (client_id = auth.uid());
CREATE POLICY "collaborator_read_pending_orders" ON public.orders FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  ) AND status = 'Pendiente'
);
CREATE POLICY "collaborator_read_assigned_orders" ON public.orders FOR SELECT USING (assigned_to = auth.uid());
CREATE POLICY "collaborator_update_own_orders" ON public.orders FOR UPDATE USING (assigned_to = auth.uid());
CREATE POLICY "owner_admin_all_orders" ON public.orders FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Collaborators y Matrículas
CREATE POLICY "collaborator_self_select" ON public.collaborators FOR SELECT USING (auth.uid() = id);
CREATE POLICY "collaborator_self_update" ON public.collaborators FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "owner_manage_collaborators" ON public.collaborators FOR ALL USING (
  public.is_owner(auth.uid())
);
CREATE POLICY "admin_manage_collaborators" ON public.collaborators FOR ALL USING (
  public.is_admin(auth.uid())
);

CREATE POLICY "collaborator_read_own_matriculas" ON public.matriculas FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "owner_manage_matriculas" ON public.matriculas FOR ALL USING (
  public.is_owner(auth.uid())
);
CREATE POLICY "admin_manage_matriculas" ON public.matriculas FOR ALL USING (
  public.is_admin(auth.uid())
);

-- Business
CREATE POLICY "owner_full_access_business" ON public.business
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Business Settings (compatibilidad)
CREATE POLICY "owner_full_access_business_settings" ON public.business_settings
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Push Subscriptions
CREATE POLICY "user_manage_own_push_subscriptions" ON public.push_subscriptions
FOR ALL USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

-- Notifications
CREATE POLICY "user_manage_own_notifications" ON public.notifications
FOR ALL USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

-- --------------------------------------------------------------
-- 7. SEED DE CATÁLOGOS
-- --------------------------------------------------------------
INSERT INTO public.vehicles (name, description, image_url, is_active) VALUES
('Camión Pequeño', '14 pies', 'https://i.postimg.cc/DynCkfnV/camionpequeno.jpg', true),
('Furgoneta', 'Ideal para paquetería y cargas ligeras', 'https://i.postimg.cc/RV4P5C9f/furgoneta.jpg', true),
('Grúa Vehicular', 'Para remolque de autos y jeepetas', 'https://i.postimg.cc/hvgBTFmy/grua-vehiculos.jpg', true),
('Camión Grande', '22 a 28 pies', 'https://i.postimg.cc/44z8SHCc/camiongrande.jpg', true),
('Grúa de Carga', 'Para izado y movimiento de carga', 'https://i.postimg.cc/0yHZwpSf/grua.png', true),
('Motor', 'Para paquetería y entregas rápidas', 'https://i.postimg.cc/JMNgTvmd/motor.jpg', true),
('Camión Abierto', 'Carga y transporte de materiales y mineros', 'https://i.postimg.cc/Kvx9ScFT/camionminero.jpg', true)
ON CONFLICT (name) DO NOTHING;

INSERT INTO public.services (name, description, image_url, is_active, display_order) VALUES
('Transporte Comercial', 'Transporte seguro de mercancías comerciales.', 'https://i.postimg.cc/sXCdCFTD/transporte-comercial.png', true, 1),
('Paquetería', 'Envíos de paquetes seguros y rápidos.', 'https://i.postimg.cc/zBYZYmx8/paqueteria.png', true, 2),
('Carga Pesada', 'Especialistas en transporte de carga pesada.', 'https://i.postimg.cc/B65b1fbv/pesado.jpg', true, 3),
('Flete', 'Servicios de flete a nivel nacional.', 'https://i.postimg.cc/15vQnj3w/flete.png', true, 4),
('Mudanza', 'Mudanza residencial y comercial.', 'https://i.postimg.cc/HszyJd5m/mudanza.jpg', true, 5),
('Grúa Vehículo', 'Remolque de vehículos.', 'https://i.postimg.cc/hvgBTFmy/grua-vehiculos.jpg', true, 6),
('Botes Mineros', 'Alquiler y transporte de botes.', 'https://i.postimg.cc/gzL29mkt/botes-minenos.png', true, 7),
('Grúa de Carga', 'Movimiento de carga pesada.', 'https://i.postimg.cc/sDjz2rsx/grua-carga.png', true, 8)
ON CONFLICT (name) DO NOTHING;

-- =============================================================
--                      FIN DEL ESQUEMA
-- =============================================================






-- Admin/owner opcional (requiere existir en auth.users para no romper FK)
INSERT INTO public.profiles (id, full_name, email, phone, created_at, updated_at)
SELECT
  'a1bd79f0-8a12-40e3-8ee5-d24427dddf71',
  'Carlos López',
  'carloslopez@gmail.com',
  '8090000000',
  NOW(),
  NOW()
WHERE EXISTS (SELECT 1 FROM auth.users WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71')
  AND NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71');

INSERT INTO public.collaborators (id, name, email, phone, matricula, status, created_at)
SELECT
  'a1bd79f0-8a12-40e3-8ee5-d24427dddf71',
  'Carlos López',
  'carloslopez@gmail.com',
  '8090000000',
  '1338547',
  'activo',
  NOW()
WHERE EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71')
  AND NOT EXISTS (SELECT 1 FROM public.collaborators WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71');

UPDATE public.collaborators
SET role = 'administrador'
WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71';

INSERT INTO public.matriculas (user_id, matricula, status, created_at)
SELECT
  'a1bd79f0-8a12-40e3-8ee5-d24427dddf71',
  '1338547',
  'activo',
  NOW()
WHERE EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71')
  AND NOT EXISTS (
    SELECT 1 FROM public.matriculas WHERE user_id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71'
  );

UPDATE public.business
SET owner_user_id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71'
WHERE id = 1
  AND EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71');

-- Agregar columnas para aceptación de órdenes y notificaciones push
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS accepted_by uuid;
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS accepted_at timestamptz;
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS client_id text;
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS notification_subscription jsonb;
-- Columnas necesarias para asignación y estado del colaborador
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS assigned_to uuid;
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS last_collab_status text;

-- Crear índices para mejor rendimiento
CREATE INDEX IF NOT EXISTS orders_accepted_by_idx ON public.orders (accepted_by);
CREATE INDEX IF NOT EXISTS orders_client_id_idx ON public.orders (client_id);

-- Función RPC para aceptar órdenes desde el panel del colaborador
CREATE OR REPLACE FUNCTION public.accept_order(order_id_param bigint)
RETURNS public.orders
LANGUAGE sql
SECURITY DEFINER
SET search_path = public
AS $$
  UPDATE public.orders
  SET status = 'En proceso',
      accepted_by = auth.uid(),
      accepted_at = now(),
      assigned_to = auth.uid(),
      last_collab_status = 'en_camino_recoger',
      tracking_data = COALESCE(tracking_data, '[]'::jsonb) || jsonb_build_array(
        jsonb_build_object(
          'status', 'en_camino_recoger',
          'timestamp', now(),
          'message', 'Orden aceptada, en camino a recoger',
          'by', auth.uid()
        )
      )
  WHERE id = order_id_param
  RETURNING *;
$$;

-- Conceder permisos de ejecución
GRANT EXECUTE ON FUNCTION public.accept_order(bigint) TO authenticated;





-- Normaliza políticas de administrador para evitar dependencias recursivas sobre public.business
-- Reemplaza políticas 'owner_*' por políticas basadas en rol 'administrador' en collaborators

-- Vehículos
drop policy if exists "owner_all_access_vehicles" on public.vehicles;
drop policy if exists "admin_all_access_vehicles" on public.vehicles;
create policy "admin_all_access_vehicles" on public.vehicles
for all using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Servicios
drop policy if exists "owner_all_access_services" on public.services;
drop policy if exists "admin_all_access_services" on public.services;
create policy "admin_all_access_services" on public.services
for all using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Órdenes
drop policy if exists "owner_all_orders" on public.orders;
drop policy if exists "admin_all_orders" on public.orders;
create policy "admin_all_orders" on public.orders
for all using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Colaboradores (gestión completa por administradores)
drop policy if exists "owner_manage_collaborators" on public.collaborators;
drop policy if exists "admin_manage_collaborators" on public.collaborators;
create policy "admin_manage_collaborators" on public.collaborators
for all using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Matrículas
drop policy if exists "owner_manage_matriculas" on public.matriculas;
drop policy if exists "admin_manage_matriculas" on public.matriculas;
create policy "admin_manage_matriculas" on public.matriculas
for all using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Nota: Las políticas específicas de colaboradores (self select/update) y de órdenes para colaboradores
-- permanecen intactas en otras migraciones recientes.




create or replace function public.is_admin(uid uuid)
returns boolean as $$
  select exists (
    select 1
    from public.collaborators
    where id = uid
    and lower(role) = 'administrador'
  );
$$ language sql stable;



-- =============================================================
-- MIGRACIÓN: Normalización de estados de orders y utilidades para Edge Functions
-- Objetivo:
--  - Evitar errores 23514 (violación de orders_status_check)
--  - Normalizar y validar estados con un set controlado y trigger
--  - Ajustar RLS para updates de estado por colaboradores/admin
--  - Agregar tabla simple de logs para depuración de Edge Functions (opcional)
-- =============================================================

-- 1) Ampliar temporalmente el constraint de status para permitir variantes usadas
DO $$ BEGIN
  IF EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'orders_status_check') THEN
    ALTER TABLE public.orders DROP CONSTRAINT orders_status_check;
  END IF;
END $$;

-- 2) Crear ENUM opcional o mantener TEXT con CHECK. Usaremos TEXT+CHECK + trigger de normalización.
-- Catálogo de estados permitidos canónicos
-- Pendiente, Aceptada, En curso, Completada, Cancelada
-- Consideraremos variantes comunes: 'Aceptado', 'en_progreso', 'en curso', 'ACEPTADA', etc.

-- 3) Función de normalización de estado
CREATE OR REPLACE FUNCTION public.normalize_order_status(in_status text)
RETURNS text
LANGUAGE plpgsql
AS $$
DECLARE
  s text := trim(both from coalesce(in_status, ''));
BEGIN
  IF s = '' THEN
    RETURN 'Pendiente';
  END IF;
  s := replace(lower(s), '_', ' ');

  -- mapear variantes a canónicos
  IF s IN ('pendiente') THEN RETURN 'Pendiente'; END IF;
  IF s IN ('aceptada','aceptado','aceptar','accepted') THEN RETURN 'Aceptada'; END IF;
  IF s IN ('en curso','en progreso','en proceso','en transito','en tránsito') THEN RETURN 'En curso'; END IF;
  IF s IN ('completada','completado','finalizada','terminada') THEN RETURN 'Completada'; END IF;
  IF s IN ('cancelada','cancelado','anulada') THEN RETURN 'Cancelada'; END IF;

  -- Si llega algo desconocido, forzar a 'Pendiente' para no romper flujos
  RETURN 'Pendiente';
END $$;

-- 4) Trigger BEFORE INSERT/UPDATE para normalizar y validar
CREATE OR REPLACE FUNCTION public.orders_status_guard()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.status := public.normalize_order_status(NEW.status);
  -- Validación final
  IF NEW.status NOT IN ('Pendiente','Aceptada','En curso','Completada','Cancelada') THEN
    RAISE EXCEPTION 'Estado no permitido: %', NEW.status USING ERRCODE = '23514';
  END IF;
  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS trg_orders_status_guard ON public.orders;
CREATE TRIGGER trg_orders_status_guard
BEFORE INSERT OR UPDATE ON public.orders
FOR EACH ROW EXECUTE FUNCTION public.orders_status_guard();

-- 5) Reaplicar CHECK para asegurar integridad futura
ALTER TABLE public.orders
  ADD CONSTRAINT orders_status_check
  CHECK (status IN ('Pendiente','Aceptada','En curso','Completada','Cancelada'));

-- 6) Normalizar datos existentes a canónicos
UPDATE public.orders
SET status = public.normalize_order_status(status)
WHERE status IS NOT NULL;

-- 7) RLS: asegurar que colaboradores/admin puedan actualizar su orden a estados válidos
-- Ya existe collaborator_update_own_orders (assigned_to = auth.uid()). La dejamos.
-- Reforzamos owner/admin all access por si necesitan corregir estados
DO $do$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'orders'
      AND policyname = 'owner_admin_all_orders'
  ) THEN
    EXECUTE $sql$
      CREATE POLICY "owner_admin_all_orders"
      ON public.orders
      FOR ALL
      USING (public.is_owner(auth.uid()) OR public.is_admin(auth.uid()))
      WITH CHECK (public.is_owner(auth.uid()) OR public.is_admin(auth.uid()));
    $sql$;
  END IF;
END
$do$;


-- 8) Tabla simple de logs para Edge Functions (opcional)
CREATE TABLE IF NOT EXISTS public.function_logs (
  id bigint generated by default as identity primary key,
  fn_name text not null,
  level text not null default 'error',
  message text,
  payload jsonb,
  created_at timestamptz not null default now()
);

-- Policy: solo admin/owner puede leer; service_role escribe sin RLS
ALTER TABLE public.function_logs ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS function_logs_read_admin ON public.function_logs;
CREATE POLICY function_logs_read_admin ON public.function_logs
FOR SELECT USING (public.is_owner(auth.uid()) OR public.is_admin(auth.uid()));

-- 9) Nota de integración frontend/backend
-- - En inserts, no envíes status o envía 'Pendiente'.
-- - En updates desde panel-colaborador, puedes enviar 'Aceptada' o 'En curso' y el trigger lo normaliza
--   aunque llegue 'aceptado' o 'en_progreso'.
-- - Si tu Edge Function cambia estados, no se verá afectada si corre con service_role.

-- FIN MIGRACIÓN


-- --------------------------------------------------------------
-- 6.b FACTURAS (INVOICES)
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.invoices CASCADE;
CREATE TABLE public.invoices (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  order_id bigint references public.orders(id) on delete set null,
  client_id uuid references public.profiles(id) on delete set null,
  file_path text not null,
  file_url text,
  total numeric,
  status text default 'generada',
  data jsonb
);

ALTER TABLE public.invoices ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "owner_admin_all_invoices" ON public.invoices;
CREATE POLICY "owner_admin_all_invoices" ON public.invoices
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

DROP POLICY IF EXISTS "client_read_own_invoices" ON public.invoices;
CREATE POLICY "client_read_own_invoices" ON public.invoices
FOR SELECT USING (
  client_id = auth.uid()
);



-- =============================================================
-- Migration: Add Profile Sync Trigger and Fix RLS Policies
-- =============================================================

-- 1. Add trigger to sync profile names from collaborators
CREATE OR REPLACE FUNCTION public.sync_profile_name()
RETURNS trigger AS $$
BEGIN
  -- Update the profile's full_name when collaborator name changes
  UPDATE public.profiles
  SET 
    full_name = NEW.name,
    email = NEW.email,
    phone = NEW.phone,
    updated_at = NOW()
  WHERE id = NEW.id;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sync_profile_name ON public.collaborators;
CREATE TRIGGER trg_sync_profile_name
AFTER INSERT OR UPDATE OF name, email, phone ON public.collaborators
FOR EACH ROW EXECUTE FUNCTION public.sync_profile_name();

-- 2. Fix RLS policies for orders
DROP POLICY IF EXISTS "public_insert_pending_orders" ON public.orders;
CREATE POLICY "public_insert_pending_orders" ON public.orders
FOR INSERT
WITH CHECK (
  -- Allow pending orders from any client (including anonymous)
  status = 'Pendiente' AND
  -- Prevent hijacking by ensuring client_id is either null or matches auth
  (client_id IS NULL OR client_id = auth.uid()) AND
  -- Additional safety: assigned_to must be null for new orders
  assigned_to IS NULL
);

-- 3. More permissive read policy for orders (helps with 401s)
DROP POLICY IF EXISTS "public_read_pending_orders" ON public.orders;
CREATE POLICY "public_read_pending_orders" ON public.orders
FOR SELECT USING (
  -- Allow reading pending orders or own orders
  status = 'Pendiente' OR
  client_id = auth.uid() OR
  assigned_to = auth.uid() OR
  -- Admins and owners can read all
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 4. Make sure collaborator operations work
DROP POLICY IF EXISTS "collaborator_all_on_own_orders" ON public.orders;
CREATE POLICY "collaborator_all_on_own_orders" ON public.orders
FOR ALL USING (
  -- Must be an active collaborator
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  ) AND (
    -- And either the order is assigned to them
    assigned_to = auth.uid() OR
    -- Or it's pending (allowing them to accept it)
    status = 'Pendiente'
  )
) WITH CHECK (
  -- For inserts/updates, must be an active collaborator
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  )
);

-- 5. Fix collaborator self-management
DROP POLICY IF EXISTS "collaborator_self_manage" ON public.collaborators;
CREATE POLICY "collaborator_self_manage" ON public.collaborators
FOR ALL USING (
  -- Collaborators can manage their own profiles
  auth.uid() = id OR
  -- Admins and owners can manage all
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
) WITH CHECK (
  -- Similar check for insert/update
  auth.uid() = id OR
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 6. Add admin insert policy for collaborators (helps with creation)
DROP POLICY IF EXISTS "admin_insert_collaborators" ON public.collaborators;
CREATE POLICY "admin_insert_collaborators" ON public.collaborators
FOR INSERT
WITH CHECK (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 7. Ensure admins can manage profiles
DROP POLICY IF EXISTS "admin_manage_profiles" ON public.profiles;
CREATE POLICY "admin_manage_profiles" ON public.profiles
FOR ALL USING (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 8. Add profile insert for new users
DROP POLICY IF EXISTS "auth_insert_profile" ON public.profiles;
CREATE POLICY "auth_insert_profile" ON public.profiles
FOR INSERT
WITH CHECK (
  -- New users can create their profile
  auth.uid() = id
);



-- =============================================================
-- Migration: Add Profile Sync Trigger and Fix RLS Policies
-- =============================================================

-- 1. Add trigger to sync profile names from collaborators
CREATE OR REPLACE FUNCTION public.sync_profile_name()
RETURNS trigger AS $$
BEGIN
  -- Upsert into public.profiles to ensure a profile row always exists for the collaborator
  INSERT INTO public.profiles (id, full_name, email, phone, created_at, updated_at)
  VALUES (NEW.id, NEW.name, NEW.email, NEW.phone, NOW(), NOW())
  ON CONFLICT (id) DO UPDATE SET
    full_name = EXCLUDED.full_name,
    email = EXCLUDED.email,
    phone = EXCLUDED.phone,
    updated_at = NOW();

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sync_profile_name ON public.collaborators;
CREATE TRIGGER trg_sync_profile_name
AFTER INSERT OR UPDATE OF name, email, phone ON public.collaborators
FOR EACH ROW EXECUTE FUNCTION public.sync_profile_name();

-- 2. Fix RLS policies for orders
-- Ensure RLS is enabled on the tables we will modify (safe to run multiple times)
ALTER TABLE IF EXISTS public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.collaborators ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "public_insert_pending_orders" ON public.orders;
CREATE POLICY "public_insert_pending_orders" ON public.orders
FOR INSERT
WITH CHECK (
  -- Allow pending orders from any client (including anonymous)
  status = 'Pendiente' AND
  -- Prevent hijacking by ensuring client_id is either null or matches auth
  (client_id IS NULL OR client_id = auth.uid()) AND
  -- Additional safety: assigned_to must be null for new orders
  assigned_to IS NULL
);

-- 3. More permissive read policy for orders (helps with 401s)
DROP POLICY IF EXISTS "public_read_pending_orders" ON public.orders;
CREATE POLICY "public_read_pending_orders" ON public.orders
FOR SELECT USING (
  -- Allow reading pending orders or own orders
  status = 'Pendiente' OR
  client_id = auth.uid() OR
  assigned_to = auth.uid() OR
  -- Admins and owners can read all
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 4. Make sure collaborator operations work
DROP POLICY IF EXISTS "collaborator_all_on_own_orders" ON public.orders;
CREATE POLICY "collaborator_all_on_own_orders" ON public.orders
FOR ALL USING (
  -- Must be an active collaborator
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  ) AND (
    -- And either the order is assigned to them
    assigned_to = auth.uid() OR
    -- Or it's pending (allowing them to accept it)
    status = 'Pendiente'
  )
) WITH CHECK (
  -- For inserts/updates, must be an active collaborator
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  )
);

-- 5. Fix collaborator self-management
DROP POLICY IF EXISTS "collaborator_self_manage" ON public.collaborators;
CREATE POLICY "collaborator_self_manage" ON public.collaborators
FOR ALL USING (
  -- Collaborators can manage their own profiles
  auth.uid() = id OR
  -- Admins and owners can manage all
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
) WITH CHECK (
  -- Similar check for insert/update
  auth.uid() = id OR
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 6. Add admin insert policy for collaborators (helps with creation)
DROP POLICY IF EXISTS "admin_insert_collaborators" ON public.collaborators;
CREATE POLICY "admin_insert_collaborators" ON public.collaborators
FOR INSERT
WITH CHECK (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 7. Ensure admins can manage profiles
DROP POLICY IF EXISTS "admin_manage_profiles" ON public.profiles;
CREATE POLICY "admin_manage_profiles" ON public.profiles
FOR ALL USING (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 8. Add profile insert for new users
DROP POLICY IF EXISTS "auth_insert_profile" ON public.profiles;
CREATE POLICY "auth_insert_profile" ON public.profiles
FOR INSERT
WITH CHECK (
  -- New users can create their profile
  auth.uid() = id
);




-- Normaliza políticas de administrador para evitar dependencias recursivas sobre public.business
-- Reemplaza políticas 'owner_*' por políticas basadas en rol 'administrador' en collaborators

-- Vehículos
drop policy if exists "owner_all_access_vehicles" on public.vehicles;
drop policy if exists "admin_all_access_vehicles" on public.vehicles;
create policy "admin_all_access_vehicles" on public.vehicles
for all using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Servicios
drop policy if exists "owner_all_access_services" on public.services;
drop policy if exists "admin_all_access_services" on public.services;
create policy "admin_all_access_services" on public.services
for all using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Órdenes
drop policy if exists "owner_all_orders" on public.orders;
drop policy if exists "admin_all_orders" on public.orders;
create policy "admin_all_orders" on public.orders
for all using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Colaboradores (gestión completa por administradores)
drop policy if exists "owner_manage_collaborators" on public.collaborators;
drop policy if exists "admin_manage_collaborators" on public.collaborators;
create policy "admin_manage_collaborators" on public.collaborators
for all using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Matrículas
drop policy if exists "owner_manage_matriculas" on public.matriculas;
drop policy if exists "admin_manage_matriculas" on public.matriculas;
create policy "admin_manage_matriculas" on public.matriculas
for all using (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
) with check (
  exists (
    select 1 from public.collaborators c
    where c.id = auth.uid() and lower(c.role) = 'administrador'
  )
);

-- Nota: Las políticas específicas de colaboradores (self select/update) y de órdenes para colaboradores
-- permanecen intactas en otras migraciones recientes.



-- =============================================================
-- MIGRACIÓN: Normalización de estados de orders y utilidades para Edge Functions
-- Objetivo:
--  - Evitar errores 23514 (violación de orders_status_check)
--  - Normalizar y validar estados con un set controlado y trigger
--  - Ajustar RLS para updates de estado por colaboradores/admin
--  - Agregar tabla simple de logs para depuración de Edge Functions (opcional)
-- =============================================================

-- 1) Ampliar temporalmente el constraint de status para permitir variantes usadas
DO $$ BEGIN
  IF EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'orders_status_check') THEN
    ALTER TABLE public.orders DROP CONSTRAINT orders_status_check;
  END IF;
END $$;

-- 2) Crear ENUM opcional o mantener TEXT con CHECK. Usaremos TEXT+CHECK + trigger de normalización.
-- Catálogo de estados permitidos canónicos
-- Pendiente, Aceptada, En curso, Completada, Cancelada
-- Consideraremos variantes comunes: 'Aceptado', 'en_progreso', 'en curso', 'ACEPTADA', etc.

-- 3) Función de normalización de estado
CREATE OR REPLACE FUNCTION public.normalize_order_status(in_status text)
RETURNS text
LANGUAGE plpgsql
AS $$
DECLARE
  s text := trim(both from coalesce(in_status, ''));
BEGIN
  IF s = '' THEN
    RETURN 'Pendiente';
  END IF;
  s := replace(lower(s), '_', ' ');

  -- mapear variantes a canónicos
  IF s IN ('pendiente') THEN RETURN 'Pendiente'; END IF;
  IF s IN ('aceptada','aceptado','aceptar','accepted') THEN RETURN 'Aceptada'; END IF;
  IF s IN ('en curso','en progreso','en proceso','en transito','en tránsito') THEN RETURN 'En curso'; END IF;
  IF s IN ('completada','completado','finalizada','terminada') THEN RETURN 'Completada'; END IF;
  IF s IN ('cancelada','cancelado','anulada') THEN RETURN 'Cancelada'; END IF;

  -- Si llega algo desconocido, forzar a 'Pendiente' para no romper flujos
  RETURN 'Pendiente';
END $$;

-- 4) Trigger BEFORE INSERT/UPDATE para normalizar y validar
CREATE OR REPLACE FUNCTION public.orders_status_guard()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.status := public.normalize_order_status(NEW.status);
  -- Validación final
  IF NEW.status NOT IN ('Pendiente','Aceptada','En curso','Completada','Cancelada') THEN
    RAISE EXCEPTION 'Estado no permitido: %', NEW.status USING ERRCODE = '23514';
  END IF;
  RETURN NEW;
END $$;

DROP TRIGGER IF EXISTS trg_orders_status_guard ON public.orders;
CREATE TRIGGER trg_orders_status_guard
BEFORE INSERT OR UPDATE ON public.orders
FOR EACH ROW EXECUTE FUNCTION public.orders_status_guard();

-- 5) Reaplicar CHECK para asegurar integridad futura
ALTER TABLE public.orders
  ADD CONSTRAINT orders_status_check
  CHECK (status IN ('Pendiente','Aceptada','En curso','Completada','Cancelada'));

-- 6) Normalizar datos existentes a canónicos
UPDATE public.orders
SET status = public.normalize_order_status(status)
WHERE status IS NOT NULL;

-- 7) RLS: asegurar que colaboradores/admin puedan actualizar su orden a estados válidos
-- Ya existe collaborator_update_own_orders (assigned_to = auth.uid()). La dejamos.
-- Reforzamos owner/admin all access por si necesitan corregir estados
DO $do$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies
    WHERE schemaname = 'public'
      AND tablename = 'orders'
      AND policyname = 'owner_admin_all_orders'
  ) THEN
    EXECUTE $sql$
      CREATE POLICY "owner_admin_all_orders"
      ON public.orders
      FOR ALL
      USING (public.is_owner(auth.uid()) OR public.is_admin(auth.uid()))
      WITH CHECK (public.is_owner(auth.uid()) OR public.is_admin(auth.uid()));
    $sql$;
  END IF;
END
$do$;


-- 8) Tabla simple de logs para Edge Functions (opcional)
CREATE TABLE IF NOT EXISTS public.function_logs (
  id bigint generated by default as identity primary key,
  fn_name text not null,
  level text not null default 'error',
  message text,
  payload jsonb,
  created_at timestamptz not null default now()
);

-- Policy: solo admin/owner puede leer; service_role escribe sin RLS
ALTER TABLE public.function_logs ENABLE ROW LEVEL SECURITY;
DROP POLICY IF EXISTS function_logs_read_admin ON public.function_logs;
CREATE POLICY function_logs_read_admin ON public.function_logs
FOR SELECT USING (public.is_owner(auth.uid()) OR public.is_admin(auth.uid()));

-- 9) Nota de integración frontend/backend
-- - En inserts, no envíes status o envía 'Pendiente'.
-- - En updates desde panel-colaborador, puedes enviar 'Aceptada' o 'En curso' y el trigger lo normaliza
--   aunque llegue 'aceptado' o 'en_progreso'.
-- - Si tu Edge Function cambia estados, no se verá afectada si corre con service_role.

-- FIN MIGRACIÓN



-- --------------------------------------------------------------
-- 6.b FACTURAS (INVOICES)
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.invoices CASCADE;
CREATE TABLE public.invoices (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  order_id bigint references public.orders(id) on delete set null,
  client_id uuid references public.profiles(id) on delete set null,
  file_path text not null,
  file_url text,
  total numeric,
  status text default 'generada',
  data jsonb
);

ALTER TABLE public.invoices ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "owner_admin_all_invoices" ON public.invoices;
CREATE POLICY "owner_admin_all_invoices" ON public.invoices
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

DROP POLICY IF EXISTS "client_read_own_invoices" ON public.invoices;
CREATE POLICY "client_read_own_invoices" ON public.invoices
FOR SELECT USING (
  client_id = auth.uid()
);



-- =============================================================
-- Migration: Add Profile Sync Trigger and Fix RLS Policies
-- =============================================================

-- 1. Add trigger to sync profile names from collaborators
CREATE OR REPLACE FUNCTION public.sync_profile_name()
RETURNS trigger AS $$
BEGIN
  -- Update the profile's full_name when collaborator name changes
  UPDATE public.profiles
  SET 
    full_name = NEW.name,
    email = NEW.email,
    phone = NEW.phone,
    updated_at = NOW()
  WHERE id = NEW.id;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sync_profile_name ON public.collaborators;
CREATE TRIGGER trg_sync_profile_name
AFTER INSERT OR UPDATE OF name, email, phone ON public.collaborators
FOR EACH ROW EXECUTE FUNCTION public.sync_profile_name();

-- 2. Fix RLS policies for orders
DROP POLICY IF EXISTS "public_insert_pending_orders" ON public.orders;
CREATE POLICY "public_insert_pending_orders" ON public.orders
FOR INSERT
WITH CHECK (
  -- Allow pending orders from any client (including anonymous)
  status = 'Pendiente' AND
  -- Prevent hijacking by ensuring client_id is either null or matches auth
  (client_id IS NULL OR client_id = auth.uid()) AND
  -- Additional safety: assigned_to must be null for new orders
  assigned_to IS NULL
);

-- 3. More permissive read policy for orders (helps with 401s)
DROP POLICY IF EXISTS "public_read_pending_orders" ON public.orders;
CREATE POLICY "public_read_pending_orders" ON public.orders
FOR SELECT USING (
  -- Allow reading pending orders or own orders
  status = 'Pendiente' OR
  client_id = auth.uid() OR
  assigned_to = auth.uid() OR
  -- Admins and owners can read all
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 4. Make sure collaborator operations work
DROP POLICY IF EXISTS "collaborator_all_on_own_orders" ON public.orders;
CREATE POLICY "collaborator_all_on_own_orders" ON public.orders
FOR ALL USING (
  -- Must be an active collaborator
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  ) AND (
    -- And either the order is assigned to them
    assigned_to = auth.uid() OR
    -- Or it's pending (allowing them to accept it)
    status = 'Pendiente'
  )
) WITH CHECK (
  -- For inserts/updates, must be an active collaborator
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  )
);

-- 5. Fix collaborator self-management
DROP POLICY IF EXISTS "collaborator_self_manage" ON public.collaborators;
CREATE POLICY "collaborator_self_manage" ON public.collaborators
FOR ALL USING (
  -- Collaborators can manage their own profiles
  auth.uid() = id OR
  -- Admins and owners can manage all
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
) WITH CHECK (
  -- Similar check for insert/update
  auth.uid() = id OR
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 6. Add admin insert policy for collaborators (helps with creation)
DROP POLICY IF EXISTS "admin_insert_collaborators" ON public.collaborators;
CREATE POLICY "admin_insert_collaborators" ON public.collaborators
FOR INSERT
WITH CHECK (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 7. Ensure admins can manage profiles
DROP POLICY IF EXISTS "admin_manage_profiles" ON public.profiles;
CREATE POLICY "admin_manage_profiles" ON public.profiles
FOR ALL USING (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 8. Add profile insert for new users
DROP POLICY IF EXISTS "auth_insert_profile" ON public.profiles;
CREATE POLICY "auth_insert_profile" ON public.profiles
FOR INSERT
WITH CHECK (
  -- New users can create their profile
  auth.uid() = id
);

-- =============================================================
-- Migration: Add Profile Sync Trigger and Fix RLS Policies
-- =============================================================

-- 1. Add trigger to sync profile names from collaborators
CREATE OR REPLACE FUNCTION public.sync_profile_name()
RETURNS trigger AS $$
BEGIN
  -- Upsert into public.profiles to ensure a profile row always exists for the collaborator
  INSERT INTO public.profiles (id, full_name, email, phone, created_at, updated_at)
  VALUES (NEW.id, NEW.name, NEW.email, NEW.phone, NOW(), NOW())
  ON CONFLICT (id) DO UPDATE SET
    full_name = EXCLUDED.full_name,
    email = EXCLUDED.email,
    phone = EXCLUDED.phone,
    updated_at = NOW();

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sync_profile_name ON public.collaborators;
CREATE TRIGGER trg_sync_profile_name
AFTER INSERT OR UPDATE OF name, email, phone ON public.collaborators
FOR EACH ROW EXECUTE FUNCTION public.sync_profile_name();

-- 2. Fix RLS policies for orders
-- Ensure RLS is enabled on the tables we will modify (safe to run multiple times)
ALTER TABLE IF EXISTS public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE IF EXISTS public.collaborators ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "public_insert_pending_orders" ON public.orders;
CREATE POLICY "public_insert_pending_orders" ON public.orders
FOR INSERT
WITH CHECK (
  -- Allow pending orders from any client (including anonymous)
  status = 'Pendiente' AND
  -- Prevent hijacking by ensuring client_id is either null or matches auth
  (client_id IS NULL OR client_id = auth.uid()) AND
  -- Additional safety: assigned_to must be null for new orders
  assigned_to IS NULL
);

-- 3. More permissive read policy for orders (helps with 401s)
DROP POLICY IF EXISTS "public_read_pending_orders" ON public.orders;
CREATE POLICY "public_read_pending_orders" ON public.orders
FOR SELECT USING (
  -- Allow reading pending orders or own orders
  status = 'Pendiente' OR
  client_id = auth.uid() OR
  assigned_to = auth.uid() OR
  -- Admins and owners can read all
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 4. Make sure collaborator operations work
DROP POLICY IF EXISTS "collaborator_all_on_own_orders" ON public.orders;
CREATE POLICY "collaborator_all_on_own_orders" ON public.orders
FOR ALL USING (
  -- Must be an active collaborator
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  ) AND (
    -- And either the order is assigned to them
    assigned_to = auth.uid() OR
    -- Or it's pending (allowing them to accept it)
    status = 'Pendiente'
  )
) WITH CHECK (
  -- For inserts/updates, must be an active collaborator
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  )
);

-- 5. Fix collaborator self-management
DROP POLICY IF EXISTS "collaborator_self_manage" ON public.collaborators;
CREATE POLICY "collaborator_self_manage" ON public.collaborators
FOR ALL USING (
  -- Collaborators can manage their own profiles
  auth.uid() = id OR
  -- Admins and owners can manage all
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
) WITH CHECK (
  -- Similar check for insert/update
  auth.uid() = id OR
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 6. Add admin insert policy for collaborators (helps with creation)
DROP POLICY IF EXISTS "admin_insert_collaborators" ON public.collaborators;
CREATE POLICY "admin_insert_collaborators" ON public.collaborators
FOR INSERT
WITH CHECK (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 7. Ensure admins can manage profiles
DROP POLICY IF EXISTS "admin_manage_profiles" ON public.profiles;
CREATE POLICY "admin_manage_profiles" ON public.profiles
FOR ALL USING (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- 8. Add profile insert for new users
DROP POLICY IF EXISTS "auth_insert_profile" ON public.profiles;
CREATE POLICY "auth_insert_profile" ON public.profiles
FOR INSERT
WITH CHECK (
  -- New users can create their profile
  auth.uid() = id
);

-- Admin/owner opcional (requiere existir en auth.users para no romper FK)
INSERT INTO public.profiles (id, full_name, email, phone, created_at, updated_at)
SELECT
  'a1bd79f0-8a12-40e3-8ee5-d24427dddf71',
  'Carlos López',
  'carloslopez@gmail.com',
  '8090000000',
  NOW(),
  NOW()
WHERE EXISTS (SELECT 1 FROM auth.users WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71')
  AND NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71');

INSERT INTO public.collaborators (id, name, email, phone, matricula, status, created_at)
SELECT
  'a1bd79f0-8a12-40e3-8ee5-d24427dddf71',
  'Carlos López',
  'carloslopez@gmail.com',
  '8090000000',
  '1338547',
  'activo',
  NOW()
WHERE EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71')
  AND NOT EXISTS (SELECT 1 FROM public.collaborators WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71');

UPDATE public.collaborators
SET role = 'administrador'
WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71';

INSERT INTO public.matriculas (user_id, matricula, status, created_at)
SELECT
  'a1bd79f0-8a12-40e3-8ee5-d24427dddf71',
  '1338547',
  'activo',
  NOW()
WHERE EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71')
  AND NOT EXISTS (
    SELECT 1 FROM public.matriculas WHERE user_id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71'
  );

UPDATE public.business
SET owner_user_id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71'
WHERE id = 1
  AND EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71');

-- Script de migración para implementar el código aleatorio de órdenes y corregir client_id
-- Fecha: 2024

-- 1. Eliminar la secuencia antigua que ya no se necesita
DROP SEQUENCE IF EXISTS public.orders_short_id_seq;

-- 2. Crear la nueva función para generar códigos aleatorios en formato ORD-YYYYMMDD-RANDOM
CREATE OR REPLACE FUNCTION public.generate_order_short_id()
RETURNS TEXT AS $$
DECLARE
    fecha_actual TEXT;
    codigo_aleatorio TEXT;
BEGIN
    -- Formato: ORD-YYYYMMDD-RANDOM
    fecha_actual := to_char(current_date, 'YYYYMMDD');
    codigo_aleatorio := upper(substring(md5(random()::text) from 1 for 6));
    RETURN 'ORD-' || fecha_actual || '-' || codigo_aleatorio;
END;
$$ LANGUAGE plpgsql;

-- 3. Crear índice para mejorar el rendimiento de búsquedas por short_id
CREATE INDEX IF NOT EXISTS idx_orders_short_id ON public.orders(short_id);

-- 4. Asegurarse de que la columna client_id existe en la tabla orders
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'orders' 
        AND column_name = 'client_id'
    ) THEN
        ALTER TABLE public.orders ADD COLUMN client_id UUID REFERENCES auth.users(id);
        CREATE INDEX IF NOT EXISTS idx_orders_client_id ON public.orders(client_id);
    END IF;
END $$;

-- Script de migración para implementar el código aleatorio de órdenes y corregir client_id
-- Fecha: 2024

-- 1. Eliminar la secuencia antigua que ya no se necesita
DROP SEQUENCE IF EXISTS public.orders_short_id_seq;

-- 2. Crear la nueva función para generar códigos aleatorios en formato ORD-YYYYMMDD-RANDOM
CREATE OR REPLACE FUNCTION public.generate_order_short_id()
RETURNS TEXT AS $$
DECLARE
    fecha_actual TEXT;
    codigo_aleatorio TEXT;
BEGIN
    -- Formato: ORD-YYYYMMDD-RANDOM
    fecha_actual := to_char(current_date, 'YYYYMMDD');
    codigo_aleatorio := upper(substring(md5(random()::text) from 1 for 6));
    RETURN 'ORD-' || fecha_actual || '-' || codigo_aleatorio;
END;
$$ LANGUAGE plpgsql;

-- 3. Crear índice para mejorar el rendimiento de búsquedas por short_id
CREATE INDEX IF NOT EXISTS idx_orders_short_id ON public.orders(short_id);

-- 4. Asegurarse de que la columna client_id existe en la tabla orders
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND table_name = 'orders' 
        AND column_name = 'client_id'
    ) THEN
        ALTER TABLE public.orders ADD COLUMN client_id UUID REFERENCES auth.users(id);
        CREATE INDEX IF NOT EXISTS idx_orders_client_id ON public.orders(client_id);
    END IF;
END $$;

-- 5. Actualizar las políticas RLS para permitir a los clientes ver sus propias órdenes
CREATE POLICY IF NOT EXISTS "clients_view_own_orders" ON public.orders
FOR SELECT USING (client_id = auth.uid());

-- 6. Regenerar los códigos de órdenes existentes (opcional - usar con precaución)
-- Comentado por defecto para evitar cambios no deseados en datos existentes
/*
UPDATE public.orders
SET short_id = public.generate_order_short_id()
WHERE true;
*/

-- Nota: El código en cliente.js debe ser actualizado para asignar correctamente el client_id
-- cuando un usuario autenticado crea una orden.
-- 6. Regenerar los códigos de órdenes existentes (opcional - usar con precaución)
-- Comentado por defecto para evitar cambios no deseados en datos existentes
/*
UPDATE public.orders
SET short_id = public.generate_order_short_id()
WHERE true;
*/

-- Nota: El código en cliente.js debe ser actualizado para asignar correctamente el client_id
-- cuando un usuario autenticado crea una orden.


-- Asegura políticas RLS para evitar 401 en inserts con select de órdenes pendientes
-- Ejecutar en Supabase SQL editor

alter table if exists public.orders enable row level security;

-- Permitir INSERT de órdenes en estado Pendiente (anon/autenticados)
drop policy if exists "public_insert_pending_orders" on public.orders;
create policy "public_insert_pending_orders" on public.orders
for insert
with check (
  status = 'Pendiente' and (client_id is null or client_id = auth.uid()) and assigned_to is null
);

-- Permitir SELECT de órdenes pendientes para evitar 401 en retorno de insert
drop policy if exists "public_read_pending_orders" on public.orders;
create policy "public_read_pending_orders" on public.orders
for select using (
  status = 'Pendiente' or client_id = auth.uid() or assigned_to = auth.uid() or public.is_owner(auth.uid()) or public.is_admin(auth.uid())
);

-- Mantener otras políticas comunes
drop policy if exists "clients_read_own_orders" on public.orders;
create policy "clients_read_own_orders" on public.orders for select using (client_id = auth.uid());

drop policy if exists "collaborator_read_assigned_orders" on public.orders;
create policy "collaborator_read_assigned_orders" on public.orders for select using (assigned_to = auth.uid());

drop policy if exists "owner_admin_all_orders" on public.orders;
create policy "owner_admin_all_orders" on public.orders
for all using (public.is_owner(auth.uid()) or public.is_admin(auth.uid()))
with check (public.is_owner(auth.uid()) or public.is_admin(auth.uid()));

-- Nota: El trigger "trg_orders_set_tracking" ya establece tracking_url automáticamente en el backend.




-- Agregar campo push_subscription a orders (para usuarios anónimos o invitados)
ALTER TABLE public.orders
ADD COLUMN IF NOT EXISTS push_subscription JSONB;


-- Agregar columnas para aceptación de órdenes y notificaciones push
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS accepted_by uuid;
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS accepted_at timestamptz;
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS client_id text;
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS notification_subscription jsonb;
-- Columnas necesarias para asignación y estado del colaborador
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS assigned_to uuid;
ALTER TABLE public.orders ADD COLUMN IF NOT EXISTS last_collab_status text;

-- Crear índices para mejor rendimiento
CREATE INDEX IF NOT EXISTS orders_accepted_by_idx ON public.orders (accepted_by);
CREATE INDEX IF NOT EXISTS orders_client_id_idx ON public.orders (client_id);

-- =====================================================
-- MIGRACIÓN: Sistema de IDs Seguros para Orders
-- =====================================================
-- Fecha: $(date)
-- Descripción: Implementa sistema dual de IDs:
--   - supabase_seq_id: Secuencial interno (123, 124, 125...)
--   - client_tracking_id: ID aleatorio único para cliente (32 chars hex)

BEGIN;

-- Extensiones necesarias
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Crear secuencia para supabase_seq_id (empezando en 123)
CREATE SEQUENCE IF NOT EXISTS orders_supabase_seq_id_seq
    START WITH 123
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;

-- =====================================================
-- MIGRACIÓN SEGURA: Agregar client_tracking_id
-- =====================================================

DO $$
BEGIN
  -- Agregar client_tracking_id si no existe
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'orders' AND column_name = 'client_tracking_id'
  ) THEN
    RAISE NOTICE 'Agregando columna client_tracking_id...';
    
    -- Crear la columna
    ALTER TABLE public.orders ADD COLUMN client_tracking_id TEXT;
    
    -- Generar IDs aleatorios únicos para registros existentes
    UPDATE public.orders 
    SET client_tracking_id = encode(gen_random_bytes(16), 'hex')
    WHERE client_tracking_id IS NULL;
    
    -- Hacer la columna NOT NULL y establecer default
    ALTER TABLE public.orders ALTER COLUMN client_tracking_id SET NOT NULL;
    ALTER TABLE public.orders ALTER COLUMN client_tracking_id SET DEFAULT encode(gen_random_bytes(16), 'hex');
    
    RAISE NOTICE 'Columna client_tracking_id agregada exitosamente.';
  ELSE
    RAISE NOTICE 'Columna client_tracking_id ya existe, saltando...';
  END IF;
END $$;

-- =====================================================
-- MIGRACIÓN SEGURA: Agregar supabase_seq_id
-- =====================================================

DO $$
DECLARE
  max_seq_id BIGINT;
BEGIN
  -- Agregar supabase_seq_id si no existe
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'orders' AND column_name = 'supabase_seq_id'
  ) THEN
    RAISE NOTICE 'Agregando columna supabase_seq_id...';
    
    -- Crear la columna
    ALTER TABLE public.orders ADD COLUMN supabase_seq_id BIGINT;
    
    -- Asignar valores secuenciales a registros existentes (empezando en 123)
    WITH numbered_orders AS (
      SELECT id, ROW_NUMBER() OVER (ORDER BY created_at, id) + 122 as seq_num
      FROM public.orders
      WHERE supabase_seq_id IS NULL
    )
    UPDATE public.orders 
    SET supabase_seq_id = numbered_orders.seq_num
    FROM numbered_orders
    WHERE public.orders.id = numbered_orders.id;
    
    -- Obtener el máximo valor asignado
    SELECT COALESCE(MAX(supabase_seq_id), 122) INTO max_seq_id FROM public.orders;
    
    -- Actualizar la secuencia al siguiente valor disponible
    PERFORM setval('orders_supabase_seq_id_seq', max_seq_id + 1, false);
    
    -- Hacer la columna NOT NULL con default de secuencia
    ALTER TABLE public.orders ALTER COLUMN supabase_seq_id SET NOT NULL;
    ALTER TABLE public.orders ALTER COLUMN supabase_seq_id SET DEFAULT nextval('orders_supabase_seq_id_seq');
    
    RAISE NOTICE 'Columna supabase_seq_id agregada. Próximo valor: %', max_seq_id + 1;
  ELSE
    RAISE NOTICE 'Columna supabase_seq_id ya existe, saltando...';
  END IF;
END $$;

-- =====================================================
-- ÍNDICES Y CONSTRAINTS
-- =====================================================

-- Crear índices únicos
CREATE UNIQUE INDEX IF NOT EXISTS idx_orders_client_tracking_id ON public.orders(client_tracking_id);
CREATE UNIQUE INDEX IF NOT EXISTS idx_orders_supabase_seq_id ON public.orders(supabase_seq_id);

-- Agregar constraint de validación para client_tracking_id (32 chars hexadecimal)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'orders_client_tracking_id_hex_check'
  ) THEN
    ALTER TABLE public.orders
    ADD CONSTRAINT orders_client_tracking_id_hex_check
    CHECK (client_tracking_id ~ '^[0-9a-f]{32}$');
    
    RAISE NOTICE 'Constraint de validación hexadecimal agregado.';
  ELSE
    RAISE NOTICE 'Constraint de validación ya existe, saltando...';
  END IF;
END $$;

-- =====================================================
-- VERIFICACIÓN POST-MIGRACIÓN
-- =====================================================

DO $$
DECLARE
  total_orders INTEGER;
  orders_with_tracking_id INTEGER;
  orders_with_seq_id INTEGER;
  min_seq_id BIGINT;
  max_seq_id BIGINT;
BEGIN
  -- Contar registros
  SELECT COUNT(*) INTO total_orders FROM public.orders;
  SELECT COUNT(*) INTO orders_with_tracking_id FROM public.orders WHERE client_tracking_id IS NOT NULL;
  SELECT COUNT(*) INTO orders_with_seq_id FROM public.orders WHERE supabase_seq_id IS NOT NULL;
  
  -- Obtener rango de seq_id
  SELECT MIN(supabase_seq_id), MAX(supabase_seq_id) INTO min_seq_id, max_seq_id FROM public.orders;
  
  -- Mostrar resultados
  RAISE NOTICE '=== VERIFICACIÓN DE MIGRACIÓN ===';
  RAISE NOTICE 'Total de órdenes: %', total_orders;
  RAISE NOTICE 'Órdenes con client_tracking_id: %', orders_with_tracking_id;
  RAISE NOTICE 'Órdenes con supabase_seq_id: %', orders_with_seq_id;
  RAISE NOTICE 'Rango supabase_seq_id: % - %', min_seq_id, max_seq_id;
  
  -- Verificar integridad
  IF total_orders = orders_with_tracking_id AND total_orders = orders_with_seq_id THEN
    RAISE NOTICE '✅ Migración completada exitosamente!';
  ELSE
    RAISE WARNING '⚠️  Posibles inconsistencias detectadas. Revisar manualmente.';
  END IF;
END $$;

COMMIT;

-- =====================================================
-- NOTAS DE USO POST-MIGRACIÓN
-- =====================================================

-- Para mostrar algunos ejemplos de los nuevos IDs:
-- SELECT id, supabase_seq_id, client_tracking_id, status, created_at 
-- FROM public.orders 
-- ORDER BY supabase_seq_id 
-- LIMIT 5;

-- Para buscar por client_tracking_id:
-- SELECT * FROM public.orders WHERE client_tracking_id = 'abc123...';

-- Para buscar por supabase_seq_id:
-- SELECT * FROM public.orders WHERE supabase_seq_id = 123;


-- =====================================================
-- RPC: accept_order(order_id BIGINT)
-- Actualiza una orden identificada por supabase_seq_id
-- y agrega una entrada inicial al tracking_data
-- =====================================================

BEGIN;

-- Asegurar extensión para funciones de tiempo si se requiere
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Crear función RPC
CREATE OR REPLACE FUNCTION public.accept_order(order_id BIGINT)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  _now TIMESTAMPTZ := NOW();
BEGIN
  -- Intentar actualizar por supabase_seq_id; si existe columna short_id, también permitir coincidencia por short_id
  IF EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'orders' AND column_name = 'short_id'
  ) THEN
    UPDATE public.orders
    SET
      status = 'Aceptada',
      assigned_at = COALESCE(assigned_at, _now),
      tracking_data = (
        COALESCE(tracking_data, '[]'::jsonb)
        || jsonb_build_array(
             jsonb_build_object(
               'status', 'en_camino_recoger',
               'date', _now,
               'description', 'Orden aceptada, en camino a recoger'
             )
           )
      )
    WHERE id = order_id OR supabase_seq_id = order_id OR short_id = order_id::text;
  ELSE
    UPDATE public.orders
    SET
      status = 'Aceptada',
      assigned_at = COALESCE(assigned_at, _now),
      tracking_data = (
        COALESCE(tracking_data, '[]'::jsonb)
        || jsonb_build_array(
             jsonb_build_object(
               'status', 'en_camino_recoger',
               'date', _now,
               'description', 'Orden aceptada, en camino a recoger'
             )
           )
      )
    WHERE id = order_id OR supabase_seq_id = order_id;
  END IF;

  -- Nota: si no existió coincidencia, no se afectarán filas.
END;
$$;

-- Opcional: conceder privilegios de ejecución a roles típicos
GRANT EXECUTE ON FUNCTION public.accept_order(BIGINT) TO anon, authenticated, service_role;

COMMIT;


-- =====================================================
-- RPC: accept_order(order_id BIGINT)
-- Actualiza una orden identificada por supabase_seq_id
-- y agrega una entrada inicial al tracking_data
-- =====================================================

BEGIN;

-- Asegurar extensión para funciones de tiempo si se requiere
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Crear función RPC
CREATE OR REPLACE FUNCTION public.accept_order(order_id BIGINT)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  _now TIMESTAMPTZ := NOW();
BEGIN
  -- Intentar actualizar por supabase_seq_id; si existe columna short_id, también permitir coincidencia por short_id
  IF EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public' AND table_name = 'orders' AND column_name = 'short_id'
  ) THEN
    UPDATE public.orders
    SET
      status = 'Aceptada',
      assigned_at = COALESCE(assigned_at, _now),
      tracking_data = (
        COALESCE(tracking_data, '[]'::jsonb)
        || jsonb_build_array(
             jsonb_build_object(
               'status', 'en_camino_recoger',
               'date', _now,
               'description', 'Orden aceptada, en camino a recoger'
             )
           )
      )
    WHERE id = order_id OR supabase_seq_id = order_id OR short_id = order_id::text;
  ELSE
    UPDATE public.orders
    SET
      status = 'Aceptada',
      assigned_at = COALESCE(assigned_at, _now),
      tracking_data = (
        COALESCE(tracking_data, '[]'::jsonb)
        || jsonb_build_array(
             jsonb_build_object(
               'status', 'en_camino_recoger',
               'date', _now,
               'description', 'Orden aceptada, en camino a recoger'
             )
           )
      )
    WHERE id = order_id OR supabase_seq_id = order_id;
  END IF;

  -- Nota: si no existió coincidencia, no se afectarán filas.
END;
$$;

-- Opcional: conceder privilegios de ejecución a roles típicos
GRANT EXECUTE ON FUNCTION public.accept_order(BIGINT) TO anon, authenticated, service_role;

COMMIT;


-- Supabase RPCs y Políticas RLS para TLC
-- Ejecutar este archivo en el editor SQL de Supabase (proyecto remoto)

-- 1) Función: update_order_status
create or replace function public.update_order_status(
  order_id bigint,
  new_status text,
  collaborator_id uuid,
  tracking_entry jsonb,
  extra jsonb
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  updated jsonb;
begin
  update public.orders o
  set
    status = case
      when lower(new_status) = 'entregado' then 'Completada'
      when new_status in ('en_camino_recoger') then 'Aceptada'
      when new_status in ('cargando','en_camino_entregar') then 'En curso'
      else status
    end,
    assigned_to = coalesce(o.assigned_to, collaborator_id),
    assigned_at = case when new_status = 'en_camino_recoger' then now() else assigned_at end,
    completed_at = case when lower(new_status) = 'entregado' then now() else completed_at end,
    last_collab_status = new_status,
    tracking_data = coalesce(o.tracking_data, '[]'::jsonb) || jsonb_build_array(tracking_entry),
    -- aplicar campos extra si vienen (monto/metodo)
    monto_cobrado = coalesce((extra->>'monto_cobrado')::numeric, o.monto_cobrado),
    metodo_pago = coalesce(extra->>'metodo_pago', o.metodo_pago)
  where o.id = order_id
    and (o.assigned_to = collaborator_id or o.assigned_to is null)
  returning to_jsonb(o) into updated;

  if updated is null then
    raise exception 'No autorizado o no encontrada' using errcode = '42501';
  end if;

  return updated;
end;
$$;

grant execute on function public.update_order_status(bigint, text, uuid, jsonb, jsonb) to anon, authenticated;

-- 2) Función: set_order_amount (admin o colaborador asignado)
create or replace function public.set_order_amount(
  order_id bigint,
  amount numeric,
  method text,
  collaborator_id uuid default null
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  updated jsonb;
  user_role text;
  is_admin boolean;
begin
  -- Verificar si el usuario es administrador
  select role into user_role
  from public.profiles
  where id = auth.uid();
  
  is_admin := (user_role = 'admin');

  -- Si es admin, puede actualizar cualquier orden
  -- Si es colaborador, solo puede actualizar órdenes asignadas a él
  if is_admin then
    update public.orders o
    set monto_cobrado = amount,
        metodo_pago = method
    where o.id = order_id
    returning to_jsonb(o) into updated;
  else
    update public.orders o
    set monto_cobrado = amount,
        metodo_pago = method
    where o.id = order_id
      and (o.assigned_to = collaborator_id or o.assigned_to = auth.uid())
    returning to_jsonb(o) into updated;
  end if;

  if updated is null then
    raise exception 'No autorizado o no encontrada' using errcode = '42501';
  end if;

  return updated;
end;
$$;

grant execute on function public.set_order_amount(bigint, numeric, text, uuid) to authenticated;

-- 3) Políticas RLS de lectura para orders
alter table public.orders enable row level security;

-- Lectura para colaborador asignado
create policy if not exists orders_select_assigned_collab
  on public.orders
  for select
  to authenticated
  using (assigned_to = auth.uid());

-- Lectura para dueño/cliente
create policy if not exists orders_select_client_owner
  on public.orders
  for select
  to authenticated
  using (client_id = auth.uid());

-- Nota: las actualizaciones deben hacerse vía RPC con SECURITY DEFINER


 ========================================================
-- 🚀 Supabase RPCs + Políticas RLS para gestión de órdenes
-- Proyecto: TLC / Logística Carlos López Ortiz
-- ========================================================

-- ===-================================
-- 1️⃣ Función: update_order_status (sin modificar monto_cobrado)
-- ===================================
create or replace function public.update_order_status(
  order_id bigint,
  new_status text,
  collaborator_id uuid,
  tracking_entry jsonb
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  updated jsonb;
begin
  update public.orders o
  set
    status = case
      when lower(new_status) = 'entregado' then 'Completada'
      when new_status in ('en_camino_recoger') then 'Aceptada'
      when new_status in ('cargando','en_camino_entregar') then 'En curso'
      else status
    end,
    assigned_to = coalesce(o.assigned_to, collaborator_id),
    assigned_at = case when new_status = 'en_camino_recoger' then now() else assigned_at end,
    completed_at = case when lower(new_status) = 'entregado' then now() else completed_at end,
    last_collab_status = new_status,
    tracking_data = coalesce(o.tracking_data, '[]'::jsonb) || jsonb_build_array(tracking_entry)
  where o.id = order_id
    and (o.assigned_to = collaborator_id or o.assigned_to is null)
  returning to_jsonb(o) into updated;

  if updated is null then
    raise exception 'No autorizado o no encontrada' using errcode = '42501';
  end if;

  return updated;
end;
$$;

grant execute on function public.update_order_status(bigint, text, uuid, jsonb) to anon, authenticated;

-- ===================================
-- 2️⃣ Función: set_order_amount (solo administrador)
-- ===================================
create or replace function public.set_order_amount_admin(
  order_id bigint,
  amount numeric,
  method text
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  updated jsonb;
begin
  -- ⚠️ Solo usuarios con rol 'service_role' o administradores internos
  if auth.role() != 'service_role' then
    raise exception 'Acceso restringido: solo administradores pueden modificar montos.' using errcode = '42501';
  end if;

  update public.orders o
  set monto_cobrado = amount,
      metodo_pago = method
  where o.id = order_id
  returning to_jsonb(o) into updated;

  if updated is null then
    raise exception 'Orden no encontrada' using errcode = 'P0002';
  end if;

  return updated;
end;
$$;

grant execute on function public.set_order_amount_admin(bigint, numeric, text) to service_role;

-- ===================================
-- 3️⃣ Políticas RLS para la tabla orders
-- ===================================
alter table public.orders enable row level security;

-- 🟢 Lectura para colaboradores autenticados asignados
drop policy if exists orders_select_assigned_collab on public.orders;
create policy orders_select_assigned_collab
  on public.orders
  for select
  to authenticated
  using (assigned_to = auth.uid());

-- 🟢 Lectura para clientes autenticados (propietarios de la orden)
drop policy if exists orders_select_client_owner on public.orders;
create policy orders_select_client_owner
  on public.orders
  for select
  to authenticated
  using (client_id = auth.uid());

-- 🟢 Lectura pública (seguimiento anónimo)
drop policy if exists orders_select_anon on public.orders;
create policy orders_select_anon
  on public.orders
  for select
  to anon
  using (true);

-- 🟢 Inserción pública (clientes pueden crear pedidos)
drop policy if exists orders_insert_anon on public.orders;
create policy orders_insert_anon
  on public.orders
  for insert
  to anon
  with check (true);

-- ❌ Bloquear updates directos desde el cliente o colaborador
drop policy if exists orders_update_direct on public.orders;
create policy orders_update_direct
  on public.orders
  for update
  to authenticated, anon
  using (false)
  with check (false);

-- ✅ Solo el administrador (service_role) puede actualizar campos financieros
drop policy if exists orders_update_admin on public.orders;
create policy orders_update_admin
  on public.orders
  for update
  to service_role
  using (true)
  with check (true);

-- ========================================================
-- ✅ Fin del script
-- ========================================================
-- Tabla de clientes para solicitudes sin usuario autenticado

create table if not exists public.clients (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  phone text,
  email text,
  created_at timestamptz not null default now()
);

-- Añadir columna en orders para referenciar contacto de cliente
do $$ begin
  if not exists (
    select 1 from information_schema.columns 
    where table_schema = 'public' and table_name = 'orders' and column_name = 'client_contact_id'
  ) then
    alter table public.orders add column client_contact_id uuid;
  end if;
end $$;

-- FK hacia clients.id
do $$ begin
  if not exists (
    select 1 from pg_constraint where conname = 'orders_client_contact_id_fkey'
  ) then
    alter table public.orders
      add constraint orders_client_contact_id_fkey
      foreign key (client_contact_id)
      references public.clients(id)
      on delete set null;
  end if;
end $$;

-- RLS para clients (permitir insert/select a anon y authenticated)
alter table public.clients enable row level security;

do $$ begin
  if not exists (
    select 1 from pg_policies where schemaname = 'public' and tablename = 'clients' and policyname = 'clients_insert_any'
  ) then
    create policy clients_insert_any on public.clients
      for insert to anon, authenticated
      with check (true);
  end if;
end $$;

do $$ begin
  if not exists (
    select 1 from pg_policies where schemaname = 'public' and tablename = 'clients' and policyname = 'clients_select_any'
  ) then
    create policy clients_select_any on public.clients
      for select to anon, authenticated
      using (true);
  end if;
end $$;


-- RPC: public.create_order_with_contact
-- Inserta una orden creando contacto en public.clients si no hay usuario autenticado
-- Devuelve la fila completa de public.orders

CREATE OR REPLACE FUNCTION public.create_order_with_contact(order_payload jsonb)
RETURNS public.orders
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_client_id uuid := (SELECT auth.uid());
  v_contact_id bigint;
  v_order public.orders;
BEGIN
  -- Si no hay usuario autenticado, crear contacto
  IF v_client_id IS NULL THEN
    INSERT INTO public.clients(name, phone, email)
    VALUES (
      NULLIF(order_payload->>'name',''),
      NULLIF(order_payload->>'phone',''),
      NULLIF(order_payload->>'email','')
    )
    RETURNING id INTO v_contact_id;
  END IF;

  -- Insertar la orden usando los datos del payload
  INSERT INTO public.orders (
    name, phone, email, rnc, empresa,
    service_id, vehicle_id, service_questions,
    pickup, delivery,
    origin_coords, destination_coords,
    date, time,
    status, estimated_price,
    tracking_data, tracking,
    client_id, client_contact_id
  ) VALUES (
    NULLIF(order_payload->>'name',''),
    NULLIF(order_payload->>'phone',''),
    NULLIF(order_payload->>'email',''),
    NULLIF(order_payload->>'rnc',''),
    NULLIF(order_payload->>'empresa',''),
    NULLIF(order_payload->>'service_id','')::int,
    NULLIF(order_payload->>'vehicle_id','')::int,
    order_payload->'service_questions',
    order_payload->>'pickup',
    order_payload->>'delivery',
    order_payload->'origin_coords',
    order_payload->'destination_coords',
    order_payload->>'date',
    order_payload->>'time',
    COALESCE(order_payload->>'status','Pendiente'),
    order_payload->>'estimated_price',
    order_payload->'tracking_data',
    COALESCE(order_payload->'tracking', order_payload->'tracking_data'),
    v_client_id,
    CASE WHEN v_client_id IS NULL THEN v_contact_id ELSE NULL END
  )
  RETURNING * INTO v_order;

  RETURN v_order;
END;
$$;

GRANT EXECUTE ON FUNCTION public.create_order_with_contact(jsonb) TO anon;
GRANT EXECUTE ON FUNCTION public.create_order_with_contact(jsonb) TO authenticated;


-- View: public.orders_with_client
-- Unifica los datos del cliente desde orders, profiles y clients
-- y expone columnas auxiliares para nombre de servicio, vehículo
-- y nombre del colaborador que completó la orden.

CREATE OR REPLACE VIEW public.orders_with_client AS
SELECT
  o.*,
  COALESCE(o.name, p.full_name, c.name) AS client_name,
  COALESCE(o.phone, p.phone, c.phone) AS client_phone,
  COALESCE(o.email, p.email, c.email) AS client_email,
  s.name AS service_name,
  v.name AS vehicle_name,
  cb.full_name AS completed_by_full_name
FROM public.orders o
LEFT JOIN public.profiles p ON p.id = o.client_id
LEFT JOIN public.clients c ON c.id = o.client_contact_id
LEFT JOIN public.services s ON s.id = o.service_id
LEFT JOIN public.vehicles v ON v.id = o.vehicle_id
LEFT JOIN public.profiles cb ON cb.id = o.completed_by;

GRANT SELECT ON public.orders_with_client TO anon;
GRANT SELECT ON public.orders_with_client TO authenticated;


-- ==========================================================
-- 🚀 Función RPC: set_order_amount (solo administradores)
-- Permite editar monto y método de pago de una orden
-- ==========================================================

CREATE OR REPLACE FUNCTION public.set_order_amount(
  order_id bigint,
  amount numeric,
  method text
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_order jsonb;
  v_role text;
BEGIN
  -- 1️⃣ Verificar si el usuario autenticado es administrador
  SELECT role INTO v_role
  FROM public.profiles
  WHERE id = auth.uid();

  IF v_role IS DISTINCT FROM 'admin' THEN
    RAISE EXCEPTION 'Acceso denegado: solo los administradores pueden modificar montos.'
      USING errcode = '42501';
  END IF;

  -- 2️⃣ Actualizar monto y método de pago de la orden
  UPDATE public.orders o
  SET 
    monto_cobrado = amount,
    metodo_pago = NULLIF(method, '')
  WHERE o.id = order_id
  RETURNING to_jsonb(o) INTO v_order;

  -- 3️⃣ Verificar si la orden existe
  IF v_order IS NULL THEN
    RAISE EXCEPTION 'Orden no encontrada o sin permisos' USING errcode = 'P0002';
  END IF;

  -- 4️⃣ Devolver orden actualizada
  RETURN v_order;
END;
$$;

-- Permitir ejecución solo a usuarios autenticados
GRANT EXECUTE ON FUNCTION public.set_order_amount(bigint, numeric, text) TO authenticated;


-- Agrega columna para guardar la suscripción push por cliente
-- Permite almacenar el objeto de suscripción (endpoint, keys, etc.)
-- en formato JSONB para notificaciones PWA.

begin;

alter table if exists public.clients
  add column if not exists push_subscription jsonb;

comment on column public.clients.push_subscription is 'Suscripción push del cliente (JSON), usada para enviar notificaciones PWA';

commit;


-- ==========================================================
-- ✅ Function: public.set_order_amount
-- ----------------------------------------------------------
-- Purpose:
--  Actualiza monto_cobrado y metodo_pago de una orden.
--  - Administradores pueden editar cualquier orden.
--  - Colaboradores solo las órdenes asignadas a ellos.
--  - Ejecuta con SECURITY DEFINER para bypass RLS de forma segura.
-- ==========================================================

CREATE OR REPLACE FUNCTION public.set_order_amount(
  order_id integer,
  amount numeric,
  method text,
  collaborator_id uuid DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_order record;
  user_role text;
  is_admin boolean;
BEGIN
  -- 1️⃣ Verificar rol del usuario autenticado
  SELECT role INTO user_role
  FROM public.profiles
  WHERE id = auth.uid();

  is_admin := (user_role = 'admin');

  -- 2️⃣ Actualización según rol
  IF is_admin THEN
    UPDATE public.orders
    SET 
      monto_cobrado = amount,
      metodo_pago = NULLIF(method, '')
    WHERE id = order_id
    RETURNING id, short_id, monto_cobrado, metodo_pago
    INTO v_order;
  ELSE
    UPDATE public.orders
    SET 
      monto_cobrado = amount,
      metodo_pago = NULLIF(method, '')
    WHERE id = order_id
      AND (assigned_to = collaborator_id OR assigned_to = auth.uid())
    RETURNING id, short_id, monto_cobrado, metodo_pago
    INTO v_order;
  END IF;

  -- 3️⃣ Validar resultado
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Orden no encontrada o sin autorización' 
      USING errcode = 'P0002';
  END IF;

  -- 4️⃣ Retornar objeto JSON con los campos actualizados
  RETURN json_build_object(
    'id', v_order.id,
    'short_id', v_order.short_id,
    'monto_cobrado', v_order.monto_cobrado,
    'metodo_pago', v_order.metodo_pago
  );
END;
$$;

-- 🔒 Permisos seguros
REVOKE ALL ON FUNCTION public.set_order_amount(integer, numeric, text, uuid) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.set_order_amount(integer, numeric, text, uuid) TO authenticated;

ALTER FUNCTION public.set_order_amount(integer, numeric, text, uuid) RENAME TO set_order_amount_admin;
ALTER FUNCTION public.set_order_amount(amount numeric, method text, order_id integer) RENAME TO set_order_amount_simple;



texto de entendimiento sobre mi proyecto asi que leelo:
 

 Este sistema gestiona órdenes de logística con soporte total para clientes anónimos y autenticados, bajo un modelo de administrador único (rol administrador en collaborators) que actúa como dueño del negocio.

🔹 Órdenes: se crean desde el frontend (con o sin login). Se identifican con:

client_id → usuarios autenticados (profiles)
client_contact_id → clientes anónimos (clients)
🔹 Notificaciones push:

Usuarios autenticados: usan push_subscriptions
Clientes anónimos: usan clients.push_subscription
Colaboradores y administradores: tienen collaborators.push_subscription
El administrador recibe notificaciones automáticas al crear o completar una orden (vía trigger en orders)
🔹 Seguridad:

RLS estricto en todas las tablas
Operaciones sensibles (editar montos, aceptar órdenes) se hacen por funciones RPC con SECURITY DEFINER
Solo administradores pueden modificar monto_cobrado y metodo_pago
🔹 Automatización:

earnings se llena automáticamente al confirmar un monto
tracking_url y short_id se generan al insertar
notifications se insertan cuando ocurren eventos clave
🔹 Compatibilidad:

Soporta PWA con notificaciones offline
Vista orders_with_client unifica datos de cliente para frontend