-- =============================================================
--        ESQUEMA TLC MEJORADO - CONTROL ADMINISTRATIVO
-- =============================================================
-- Cambios principales:
-- - Tabla ganancias con control administrativo total
-- - Funciones RPC para manejo seguro de ganancias
-- - Políticas RLS reforzadas
-- - Soporte completo para PWA
-- - Eliminación de código redundante
-- =============================================================

-- -------------------------------------------------------------
-- 1. EXTENSIONES Y FUNCIONES BASE
-- -------------------------------------------------------------
create extension if not exists pgcrypto;

-- Función auxiliar para actualizar timestamps
CREATE OR REPLACE FUNCTION public.touch_updated_at()
RETURNS trigger AS $$
BEGIN
  new.updated_at = now();
  RETURN new;
END;
$$ LANGUAGE plpgsql;

-- Funciones de verificación de roles
CREATE OR REPLACE FUNCTION public.is_owner(uid uuid)
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT EXISTS(
    SELECT 1 FROM public.business b WHERE b.owner_user_id = uid
  );
$$;

CREATE OR REPLACE FUNCTION public.is_admin(uid uuid)
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT EXISTS(
    SELECT 1 FROM public.collaborators c
    WHERE c.id = uid AND lower(coalesce(c.role, 'colaborador')) = 'administrador'
  );
$$;

-- Función para generar IDs cortos de órdenes
CREATE OR REPLACE FUNCTION public.generate_order_short_id()
RETURNS TEXT AS $$
DECLARE
    random_part TEXT;
    date_part TEXT;
BEGIN
    random_part := upper(substring(md5(random()::text) from 1 for 6));
    date_part := to_char(current_date, 'YYYYMMDD');
    RETURN 'ORD-' || date_part || '-' || random_part;
END;
$$ LANGUAGE plpgsql;

-- Función para normalizar estados de órdenes
CREATE OR REPLACE FUNCTION public.normalize_order_status(in_status text)
RETURNS text
LANGUAGE plpgsql
AS $$
DECLARE
  s text := trim(both from coalesce(in_status, ''));
BEGIN
  IF s = '' THEN
    RETURN 'Pendiente';
  END IF;
  s := replace(lower(s), '_', ' ');

  IF s IN ('pendiente') THEN RETURN 'Pendiente'; END IF;
  IF s IN ('aceptada','aceptado','aceptar','accepted') THEN RETURN 'Aceptada'; END IF;
  IF s IN ('en curso','en progreso','en proceso','en transito','en tránsito') THEN RETURN 'En curso'; END IF;
  IF s IN ('completada','completado','finalizada','terminada') THEN RETURN 'Completada'; END IF;
  IF s IN ('cancelada','cancelado','anulada') THEN RETURN 'Cancelada'; END IF;

  RETURN 'Pendiente';
END $$;

-- Trigger para normalizar estados
CREATE OR REPLACE FUNCTION public.orders_status_guard()
RETURNS trigger AS $$
BEGIN
  NEW.status := public.normalize_order_status(NEW.status);
  IF NEW.status NOT IN ('Pendiente','Aceptada','En curso','Completada','Cancelada') THEN
    RAISE EXCEPTION 'Estado no permitido: %', NEW.status USING ERRCODE = '23514';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- -------------------------------------------------------------
-- 2. TABLAS PRINCIPALES
-- -------------------------------------------------------------

-- Vehículos
DROP TABLE IF EXISTS public.vehicles CASCADE;
CREATE TABLE public.vehicles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    image_url TEXT,
    is_active BOOLEAN DEFAULT true NOT NULL
);

-- Servicios
DROP TABLE IF EXISTS public.services CASCADE;
CREATE TABLE public.services (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    image_url TEXT,
    is_active BOOLEAN DEFAULT true NOT NULL,
    display_order INT
);

-- Perfiles de usuario
DROP TABLE IF EXISTS public.profiles CASCADE;
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name TEXT,
    email TEXT,
    phone TEXT,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now()
);

-- Colaboradores
DROP TABLE IF EXISTS public.collaborators CASCADE;
CREATE TABLE public.collaborators (
    id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    name TEXT,
    email TEXT,
    phone TEXT,
    matricula TEXT,
    status TEXT DEFAULT 'activo' NOT NULL,
    role TEXT DEFAULT 'colaborador' NOT NULL CHECK (lower(role) IN ('administrador','colaborador')),
    push_subscription JSONB,
    notes TEXT,
    updated_at timestamptz not null default now()
);

-- Matrículas
DROP TABLE IF EXISTS public.matriculas CASCADE;
CREATE TABLE public.matriculas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    matricula TEXT NOT NULL,
    status TEXT DEFAULT 'activo' NOT NULL
);

-- Configuración del negocio
DROP TABLE IF EXISTS public.business CASCADE;
CREATE TABLE public.business (
  id integer primary key default 1,
  business_name text,
  address text,
  phone text,
  email text,
  rnc text CHECK (rnc ~ '^[0-9]{9,11}$' OR rnc IS NULL),
  quotation_rates jsonb,
  owner_user_id uuid references public.profiles(id) on delete set null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

-- Órdenes
DROP TABLE IF EXISTS public.orders CASCADE;
CREATE TABLE public.orders (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    short_id TEXT UNIQUE DEFAULT public.generate_order_short_id(),
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    client_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    phone TEXT NOT NULL,
    email TEXT,
    rnc TEXT,
    empresa TEXT,
    service_id BIGINT REFERENCES public.services(id) ON DELETE SET NULL,
    vehicle_id BIGINT REFERENCES public.vehicles(id) ON DELETE SET NULL,
    service_questions JSONB,
    pickup TEXT,
    delivery TEXT,
    origin_coords JSONB,
    destination_coords JSONB,
    "date" DATE,
    "time" TIME,
    status TEXT DEFAULT 'Pendiente' NOT NULL,
    assigned_to UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    assigned_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    completed_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    evidence_photos JSONB,
    rating JSONB,
    estimated_price TEXT DEFAULT 'Por confirmar',
    monto_cobrado NUMERIC,
    metodo_pago TEXT,
    tracking_data JSONB,
    tracking_url TEXT,
    updated_at timestamptz not null default now()
);

-- TABLA DE GANANCIAS - NUEVA ESTRUCTURA
DROP TABLE IF EXISTS public.ganancias CASCADE;
CREATE TABLE public.ganancias (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    order_id BIGINT NOT NULL REFERENCES public.orders(id) ON DELETE CASCADE,
    colaborador_id UUID REFERENCES public.collaborators(id) ON DELETE SET NULL,
    monto_total NUMERIC NOT NULL DEFAULT 0,
    ganancia_administrador NUMERIC NOT NULL DEFAULT 0,
    ganancia_colaborador NUMERIC NOT NULL DEFAULT 0,
    porcentaje_administrador NUMERIC NOT NULL DEFAULT 70,
    porcentaje_colaborador NUMERIC NOT NULL DEFAULT 30,
    metodo_calculo TEXT DEFAULT 'porcentaje' CHECK (metodo_calculo IN ('porcentaje', 'fijo')),
    notas TEXT,
    fecha_pago_administrador TIMESTAMPTZ,
    fecha_pago_colaborador TIMESTAMPTZ,
    estado_pago_administrador TEXT DEFAULT 'pendiente' CHECK (estado_pago_administrador IN ('pendiente', 'pagado')),
    estado_pago_colaborador TEXT DEFAULT 'pendiente' CHECK (estado_pago_colaborador IN ('pendiente', 'pagado'))
);

-- Notificaciones
DROP TABLE IF EXISTS public.notifications CASCADE;
CREATE TABLE public.notifications (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade,
  title text,
  body text,
  data jsonb,
  created_at timestamptz not null default now(),
  read_at timestamptz
);

-- Suscripciones Push PWA
DROP TABLE IF EXISTS public.push_subscriptions CASCADE;
CREATE TABLE public.push_subscriptions (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade,
  endpoint text not null,
  keys jsonb not null,
  created_at timestamptz not null default now()
);

-- Facturas
DROP TABLE IF EXISTS public.invoices CASCADE;
CREATE TABLE public.invoices (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  order_id bigint references public.orders(id) on delete set null,
  client_id uuid references public.profiles(id) on delete set null,
  file_path text not null,
  file_url text,
  total numeric,
  status text default 'generada',
  data jsonb
);

-- -------------------------------------------------------------
-- 3. ÍNDICES PARA RENDIMIENTO
-- -------------------------------------------------------------
CREATE INDEX IF NOT EXISTS idx_matriculas_user_id ON public.matriculas(user_id);
CREATE INDEX IF NOT EXISTS idx_collaborators_status ON public.collaborators(status);
CREATE INDEX IF NOT EXISTS idx_collaborators_role ON public.collaborators(role);
CREATE INDEX IF NOT EXISTS idx_collaborators_email ON public.collaborators(email);
CREATE INDEX IF NOT EXISTS idx_profiles_email ON public.profiles(email);
CREATE INDEX IF NOT EXISTS idx_orders_status ON public.orders(status);
CREATE INDEX IF NOT EXISTS idx_orders_date ON public.orders("date");
CREATE INDEX IF NOT EXISTS idx_orders_assigned_to ON public.orders(assigned_to);
CREATE INDEX IF NOT EXISTS idx_orders_client_id ON public.orders(client_id);
CREATE INDEX IF NOT EXISTS idx_ganancias_order_id ON public.ganancias(order_id);
CREATE INDEX IF NOT EXISTS idx_ganancias_colaborador_id ON public.ganancias(colaborador_id);
CREATE INDEX IF NOT EXISTS idx_notifications_user ON public.notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_push_subscriptions_user ON public.push_subscriptions(user_id);
CREATE INDEX IF NOT EXISTS idx_invoices_order ON public.invoices(order_id);

-- -------------------------------------------------------------
-- 4. TRIGGERS
-- -------------------------------------------------------------
DROP TRIGGER IF EXISTS trg_profiles_set_updated ON public.profiles;
CREATE TRIGGER trg_profiles_set_updated
BEFORE UPDATE ON public.profiles
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

DROP TRIGGER IF EXISTS trg_collaborators_touch_updated ON public.collaborators;
CREATE TRIGGER trg_collaborators_touch_updated
BEFORE UPDATE ON public.collaborators
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

DROP TRIGGER IF EXISTS trg_business_touch_updated ON public.business;
CREATE TRIGGER trg_business_touch_updated
BEFORE UPDATE ON public.business
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

DROP TRIGGER IF EXISTS trg_orders_set_tracking ON public.orders;
CREATE TRIGGER trg_orders_set_tracking
BEFORE INSERT ON public.orders
FOR EACH ROW EXECUTE FUNCTION public.set_order_tracking_url();

DROP TRIGGER IF EXISTS trg_orders_touch_updated ON public.orders;
CREATE TRIGGER trg_orders_touch_updated
BEFORE UPDATE ON public.orders
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

DROP TRIGGER IF EXISTS trg_ganancias_touch_updated ON public.ganancias;
CREATE TRIGGER trg_ganancias_touch_updated
BEFORE UPDATE ON public.ganancias
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

DROP TRIGGER IF EXISTS trg_orders_status_guard ON public.orders;
CREATE TRIGGER trg_orders_status_guard
BEFORE INSERT OR UPDATE ON public.orders
FOR EACH ROW EXECUTE FUNCTION public.orders_status_guard();

-- Trigger para sincronizar perfiles con colaboradores
CREATE OR REPLACE FUNCTION public.sync_profile_name()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, full_name, email, phone, created_at, updated_at)
  VALUES (NEW.id, NEW.name, NEW.email, NEW.phone, NOW(), NOW())
  ON CONFLICT (id) DO UPDATE SET
    full_name = EXCLUDED.full_name,
    email = EXCLUDED.email,
    phone = EXCLUDED.phone,
    updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sync_profile_name ON public.collaborators;
CREATE TRIGGER trg_sync_profile_name
AFTER INSERT OR UPDATE OF name, email, phone ON public.collaborators
FOR EACH ROW EXECUTE FUNCTION public.sync_profile_name();

-- -------------------------------------------------------------
-- 5. POLÍTICAS RLS - SEGURIDAD REFORZADA
-- -------------------------------------------------------------

-- Habilitar RLS en todas las tablas
ALTER TABLE public.vehicles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.services ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.collaborators ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.matriculas ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.business ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ganancias ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.push_subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.invoices ENABLE ROW LEVEL SECURITY;

-- Vehículos y servicios - lectura pública, administración solo admin
DROP POLICY IF EXISTS "public_read_vehicles" ON public.vehicles;
CREATE POLICY "public_read_vehicles" ON public.vehicles FOR SELECT USING (true);

DROP POLICY IF EXISTS "public_read_services" ON public.services;
CREATE POLICY "public_read_services" ON public.services FOR SELECT USING (true);

DROP POLICY IF EXISTS "admin_manage_vehicles" ON public.vehicles;
CREATE POLICY "admin_manage_vehicles" ON public.vehicles FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

DROP POLICY IF EXISTS "admin_manage_services" ON public.services;
CREATE POLICY "admin_manage_services" ON public.services FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Perfiles
DROP POLICY IF EXISTS "public_read_profiles" ON public.profiles;
CREATE POLICY "public_read_profiles" ON public.profiles FOR SELECT USING (true);

DROP POLICY IF EXISTS "users_update_own_profile" ON public.profiles;
CREATE POLICY "users_update_own_profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

DROP POLICY IF EXISTS "admin_manage_profiles" ON public.profiles;
CREATE POLICY "admin_manage_profiles" ON public.profiles FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Órdenes - políticas mejoradas
DROP POLICY IF EXISTS "public_insert_pending_orders" ON public.orders;
CREATE POLICY "public_insert_pending_orders" ON public.orders
FOR INSERT
WITH CHECK (
  status = 'Pendiente' AND 
  (client_id IS NULL OR client_id = auth.uid()) AND
  assigned_to IS NULL
);

DROP POLICY IF EXISTS "public_read_pending_orders" ON public.orders;
CREATE POLICY "public_read_pending_orders" ON public.orders
FOR SELECT USING (
  status = 'Pendiente' OR
  client_id = auth.uid() OR
  assigned_to = auth.uid() OR
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

DROP POLICY IF EXISTS "collaborator_all_on_own_orders" ON public.orders;
CREATE POLICY "collaborator_all_on_own_orders" ON public.orders
FOR ALL USING (
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  ) AND (
    assigned_to = auth.uid() OR
    status = 'Pendiente'
  )
) WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  )
);

DROP POLICY IF EXISTS "admin_all_orders" ON public.orders;
CREATE POLICY "admin_all_orders" ON public.orders
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Colaboradores
DROP POLICY IF EXISTS "collaborator_self_manage" ON public.collaborators;
CREATE POLICY "collaborator_self_manage" ON public.collaborators
FOR ALL USING (
  auth.uid() = id OR
  public.is_owner(auth.uid()) OR 
  public.is_admin(auth.uid())
);

-- Matrículas
DROP POLICY IF EXISTS "admin_manage_matriculas" ON public.matriculas;
CREATE POLICY "admin_manage_matriculas" ON public.matriculas
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- GANANCIAS - CONTROL TOTALMENTE ADMINISTRATIVO
DROP POLICY IF EXISTS "admin_control_ganancias" ON public.ganancias;
CREATE POLICY "admin_control_ganancias" ON public.ganancias
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Notificaciones y suscripciones
DROP POLICY IF EXISTS "user_manage_own_notifications" ON public.notifications;
CREATE POLICY "user_manage_own_notifications" ON public.notifications
FOR ALL USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "user_manage_own_push_subscriptions" ON public.push_subscriptions;
CREATE POLICY "user_manage_own_push_subscriptions" ON public.push_subscriptions
FOR ALL USING (auth.uid() = user_id);

-- Facturas
DROP POLICY IF EXISTS "admin_control_invoices" ON public.invoices;
CREATE POLICY "admin_control_invoices" ON public.invoices
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

DROP POLICY IF EXISTS "client_read_own_invoices" ON public.invoices;
CREATE POLICY "client_read_own_invoices" ON public.invoices
FOR SELECT USING (client_id = auth.uid());

-- -------------------------------------------------------------
-- 6. FUNCIONES RPC - FUNCIONES DEL SISTEMA
-- -------------------------------------------------------------

-- Función para aceptar órdenes
CREATE OR REPLACE FUNCTION public.accept_order(order_id BIGINT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    updated_order RECORD;
BEGIN
    -- Verificar que el usuario sea un colaborador activo
    IF NOT EXISTS (
        SELECT 1 FROM public.collaborators 
        WHERE id = auth.uid() AND status = 'activo'
    ) THEN
        RETURN json_build_object('success', false, 'error', 'Usuario no es colaborador activo');
    END IF;

    -- Actualizar la orden
    UPDATE public.orders 
    SET 
        status = 'Aceptada',
        assigned_to = auth.uid(),
        assigned_at = NOW(),
        updated_at = NOW()
    WHERE id = order_id 
        AND status = 'Pendiente' 
        AND assigned_to IS NULL
    RETURNING * INTO updated_order;

    IF NOT FOUND THEN
        RETURN json_build_object('success', false, 'error', 'Orden no disponible');
    END IF;

    RETURN json_build_object('success', true, 'order', updated_order);
END;
$$;

-- Función para actualizar estado de órdenes
CREATE OR REPLACE FUNCTION public.update_order_status(order_id BIGINT, new_status TEXT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    updated_order RECORD;
    can_update BOOLEAN := false;
BEGIN
    -- Verificar permisos
    IF public.is_owner(auth.uid()) OR public.is_admin(auth.uid()) THEN
        can_update := true;
    ELSE
        -- Colaborador puede actualizar solo sus órdenes
        SELECT true INTO can_update
        FROM public.orders 
        WHERE id = order_id 
            AND assigned_to = auth.uid()
            AND status IN ('Aceptada', 'En curso');
    END IF;

    IF NOT can_update THEN
        RETURN json_build_object('success', false, 'error', 'Sin permisos para actualizar esta orden');
    END IF;

    -- Actualizar orden
    UPDATE public.orders 
    SET 
        status = public.normalize_order_status(new_status),
        updated_at = NOW(),
        completed_at = CASE 
            WHEN public.normalize_order_status(new_status) = 'Completada' 
            THEN NOW() 
            ELSE completed_at 
        END
    WHERE id = order_id
    RETURNING * INTO updated_order;

    IF NOT FOUND THEN
        RETURN json_build_object('success', false, 'error', 'Orden no encontrada');
    END IF;

    RETURN json_build_object('success', true, 'order', updated_order);
END;
$$;

-- FUNCIÓN RPC PARA ESTABLECER MONTO Y MÉTODO DE PAGO - SOLO ADMIN
CREATE OR REPLACE FUNCTION public.set_order_amount(order_id BIGINT, amount NUMERIC, method TEXT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    updated_order RECORD;
BEGIN
    -- Verificar que sea administrador
    IF NOT (public.is_owner(auth.uid()) OR public.is_admin(auth.uid())) THEN
        RETURN json_build_object('success', false, 'error', 'Solo administradores pueden establecer montos de pago');
    END IF;

    -- Actualizar orden
    UPDATE public.orders 
    SET 
        monto_cobrado = amount,
        metodo_pago = method,
        updated_at = NOW()
    WHERE id = order_id
    RETURNING * INTO updated_order;

    IF NOT FOUND THEN
        RETURN json_build_object('success', false, 'error', 'Orden no encontrada');
    END IF;

    RETURN json_build_object('success', true, 'order', updated_order);
END;
$$;

-- FUNCIÓN RPC PARA CALCULAR Y REGISTRAR GANANCIAS - SOLO ADMIN
CREATE OR REPLACE FUNCTION public.calcular_ganancias(order_id BIGINT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    order_data RECORD;
    ganancia_data RECORD;
    porcentaje_admin NUMERIC := 70;
    porcentaje_colab NUMERIC := 30;
BEGIN
    -- Verificar que sea administrador
    IF NOT (public.is_owner(auth.uid()) OR public.is_admin(auth.uid())) THEN
        RETURN json_build_object('success', false, 'error', 'Solo administradores pueden calcular ganancias');
    END IF;

    -- Obtener datos de la orden
    SELECT * INTO order_data
    FROM public.orders 
    WHERE id = order_id AND status = 'Completada' AND monto_cobrado IS NOT NULL;

    IF NOT FOUND THEN
        RETURN json_build_object('success', false, 'error', 'Orden no válida para calcular ganancias');
    END IF;

    -- Verificar si ya existe ganancia para esta orden
    IF EXISTS (SELECT 1 FROM public.ganancias WHERE order_id = order_id) THEN
        RETURN json_build_object('success', false, 'error', 'Las ganancias ya fueron calculadas para esta orden');
    END IF;

    -- Calcular ganancias
    INSERT INTO public.ganancias (
        order_id,
        colaborador_id,
        monto_total,
        ganancia_administrador,
        ganancia_colaborador,
        porcentaje_administrador,
        porcentaje_colaborador,
        metodo_calculo
    ) VALUES (
        order_id,
        order_data.assigned_to,
        order_data.monto_cobrado,
        (order_data.monto_cobrado * porcentaje_admin / 100),
        (order_data.monto_cobrado * porcentaje_colab / 100),
        porcentaje_admin,
        porcentaje_colab,
        'porcentaje'
    ) RETURNING * INTO ganancia_data;

    RETURN json_build_object('success', true, 'ganancia', ganancia_data);
END;
$$;

-- FUNCIÓN PARA OBTENER RESUMEN DE GANANCIAS - ACCESO ADMIN
CREATE OR REPLACE FUNCTION public.obtener_resumen_ganancias(fecha_inicio DATE DEFAULT NULL, fecha_fin DATE DEFAULT NULL)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    resumen JSON;
BEGIN
    -- Verificar que sea administrador
    IF NOT (public.is_owner(auth.uid()) OR public.is_admin(auth.uid())) THEN
        RETURN json_build_object('error', 'Acceso no autorizado');
    END IF;

    -- Calcular resumen
    SELECT json_build_object(
        'total_ordenes', COUNT(*),
        'monto_total', COALESCE(SUM(monto_total), 0),
        'ganancia_administrador_total', COALESCE(SUM(ganancia_administrador), 0),
        'ganancia_colaborador_total', COALESCE(SUM(ganancia_colaborador), 0),
        'ordenes_pagadas_admin', COUNT(*) FILTER (WHERE estado_pago_administrador = 'pagado'),
        'ordenes_pagadas_colab', COUNT(*) FILTER (WHERE estado_pago_colaborador = 'pagado')
    ) INTO resumen
    FROM public.ganancias
    WHERE (fecha_inicio IS NULL OR created_at >= fecha_inicio::timestamptz)
      AND (fecha_fin IS NULL OR created_at <= fecha_fin::timestamptz);

    RETURN json_build_object('success', true, 'resumen', resumen);
END;
$$;

-- FUNCIÓN PARA MARCAR GANANCIAS COMO PAGADAS - SOLO ADMIN
CREATE OR REPLACE FUNCTION public.marcar_ganancia_pagada(ganancia_id BIGINT, tipo_pago TEXT)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    updated_ganancia RECORD;
BEGIN
    -- Verificar que sea administrador
    IF NOT (public.is_owner(auth.uid()) OR public.is_admin(auth.uid())) THEN
        RETURN json_build_object('success', false, 'error', 'Acceso no autorizado');
    END IF;

    -- Validar tipo de pago
    IF tipo_pago NOT IN ('administrador', 'colaborador') THEN
        RETURN json_build_object('success', false, 'error', 'Tipo de pago inválido');
    END IF;

    -- Actualizar ganancia
    IF tipo_pago = 'administrador' THEN
        UPDATE public.ganancias 
        SET 
            estado_pago_administrador = 'pagado',
            fecha_pago_administrador = NOW(),
            updated_at = NOW()
        WHERE id = ganancia_id
        RETURNING * INTO updated_ganancia;
    ELSE
        UPDATE public.ganancias 
        SET 
            estado_pago_colaborador = 'pagado',
            fecha_pago_colaborador = NOW(),
            updated_at = NOW()
        WHERE id = ganancia_id
        RETURNING * INTO updated_ganancia;
    END IF;

    IF NOT FOUND THEN
        RETURN json_build_object('success', false, 'error', 'Ganancia no encontrada');
    END IF;

    RETURN json_build_object('success', true, 'ganancia', updated_ganancia);
END;
$$;

-- FUNCIÓN PARA SUSCRIPCIÓN PWA
CREATE OR REPLACE FUNCTION public.guardar_suscripcion_pwa(endpoint TEXT, keys JSONB)
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    subscription RECORD;
BEGIN
    -- Verificar que el usuario esté autenticado
    IF auth.uid() IS NULL THEN
        RETURN json_build_object('success', false, 'error', 'Usuario no autenticado');
    END IF;

    -- Insertar o actualizar suscripción
    INSERT INTO public.push_subscriptions (user_id, endpoint, keys)
    VALUES (auth.uid(), endpoint, keys)
    ON CONFLICT (user_id) DO UPDATE SET
        endpoint = EXCLUDED.endpoint,
        keys = EXCLUDED.keys,
        created_at = NOW()
    RETURNING * INTO subscription;

    RETURN json_build_object('success', true, 'subscription', subscription);
END;
$$;

-- FUNCIÓN PARA OBTENER SUSCRIPCIONES PWA DE UN USUARIO
CREATE OR REPLACE FUNCTION public.obtener_suscripcion_pwa()
RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    subscription RECORD;
BEGIN
    IF auth.uid() IS NULL THEN
        RETURN json_build_object('error', 'Usuario no autenticado');
    END IF;

    SELECT * INTO subscription
    FROM public.push_subscriptions
    WHERE user_id = auth.uid();

    IF NOT FOUND THEN
        RETURN json_build_object('success', false, 'message', 'No hay suscripción activa');
    END IF;

    RETURN json_build_object('success', true, 'subscription', subscription);
END;
$$;

-- -------------------------------------------------------------
-- 7. DATOS INICIALES
-- -------------------------------------------------------------

-- Seed del negocio
INSERT INTO public.business (id, business_name, address, phone, email)
VALUES (1, 'Mi Negocio TLC', '', '', '')
ON CONFLICT (id) DO NOTHING;

-- Seed de vehículos
INSERT INTO public.vehicles (name, description) VALUES
('Sedán', 'Vehículo sedán estándar'),
('SUV', 'Vehículo tipo SUV'),
('Camioneta', 'Vehículo camioneta'),
('Moto', 'Motocicleta')
ON CONFLICT (name) DO NOTHING;

-- Seed de servicios
INSERT INTO public.services (name, description, display_order) VALUES
('Lavado Básico', 'Lavado exterior e interior básico', 1),
('Lavado Premium', 'Lavado completo con detallado', 2),
('Encerado', 'Aplicación de cera protectora', 3),
('Limpieza de Motor', 'Limpieza profunda del motor', 4)
ON CONFLICT (name) DO NOTHING;

-- -------------------------------------------------------------
-- 8. VERIFICACIÓN DE INSTALACIÓN
-- -------------------------------------------------------------

-- Función para verificar el estado del sistema
CREATE OR REPLACE FUNCTION public.verificar_sistema()
RETURNS JSON
LANGUAGE plpgsql
AS $$
DECLARE
    resultado JSON;
BEGIN
    SELECT json_build_object(
        'version', '2.0 - Control Administrativo',
        'fecha_instalacion', NOW(),
        'tablas_instaladas', (
            SELECT COUNT(*) FROM information_schema.tables 
            WHERE table_schema = 'public' AND table_name IN (
                'vehicles', 'services', 'profiles', 'collaborators', 
                'matriculas', 'business', 'orders', 'ganancias',
                'notifications', 'push_subscriptions', 'invoices'
            )
        ),
        'funciones_rpc', (
            SELECT COUNT(*) FROM pg_proc 
            WHERE proname IN (
                'accept_order', 'update_order_status', 'set_order_amount',
                'calcular_ganancias', 'obtener_resumen_ganancias',
                'marcar_ganancia_pagada', 'guardar_suscripcion_pwa',
                'obtener_suscripcion_pwa'
            )
        )
    ) INTO resultado;

    RETURN resultado;
END;
$$;