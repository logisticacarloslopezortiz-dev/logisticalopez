-- =============================================================
--        ESQUEMA COMPLETO TLC (Versión lista para Supabase)
-- =============================================================
-- Incluye:
-- - Tablas base (vehículos, servicios)
-- - Perfiles, colaboradores y matrículas
-- - Órdenes, notificaciones y suscripciones
-- - Configuración del negocio con RNC y dueño
-- - Políticas RLS seguras y triggers automáticos
-- =============================================================

-- --------------------------------------------------------------
-- 1. EXTENSIONES
-- --------------------------------------------------------------
create extension if not exists pgcrypto;

-- --------------------------------------------------------------
-- 2. TABLAS CATÁLOGO: VEHÍCULOS Y SERVICIOS
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.vehicles CASCADE;
CREATE TABLE public.vehicles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    image_url TEXT,
    is_active BOOLEAN DEFAULT true NOT NULL
);
COMMENT ON TABLE public.vehicles IS 'Catálogo de vehículos disponibles para los servicios.';

DROP TABLE IF EXISTS public.services CASCADE;
CREATE TABLE public.services (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    name TEXT NOT NULL UNIQUE,
    description TEXT,
    image_url TEXT,
    is_active BOOLEAN DEFAULT true NOT NULL,
    display_order INT
);
COMMENT ON TABLE public.services IS 'Catálogo de los servicios ofrecidos por el negocio.';

-- --------------------------------------------------------------
-- 3. USUARIOS Y COLABORADORES
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.profiles CASCADE;
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    full_name TEXT,
    email TEXT,
    phone TEXT,
    created_at timestamptz not null default now(),
    updated_at timestamptz not null default now(),
    completed_jobs INT DEFAULT 0
);
COMMENT ON TABLE public.profiles IS 'Datos públicos del usuario (sin roles, vinculados a auth.users).';

DROP TABLE IF EXISTS public.collaborators CASCADE;
CREATE TABLE public.collaborators (
    id UUID PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    name TEXT,
    email TEXT,
    phone TEXT,
    matricula TEXT,
    status TEXT DEFAULT 'activo' NOT NULL,
    role TEXT DEFAULT 'colaborador' NOT NULL CHECK (lower(role) IN ('administrador','colaborador')),
    push_subscription JSONB,
    notes TEXT,
    updated_at timestamptz not null default now()
);
COMMENT ON TABLE public.collaborators IS 'Datos operativos de colaboradores.';

DROP TABLE IF EXISTS public.matriculas CASCADE;
CREATE TABLE public.matriculas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    matricula TEXT NOT NULL,
    status TEXT DEFAULT 'activo' NOT NULL
);
COMMENT ON TABLE public.matriculas IS 'Matrículas/placas de los colaboradores.';

CREATE INDEX IF NOT EXISTS idx_matriculas_user_id ON public.matriculas(user_id);
CREATE INDEX IF NOT EXISTS idx_collaborators_status ON public.collaborators(status);
CREATE INDEX IF NOT EXISTS idx_collaborators_role ON public.collaborators(role);
CREATE INDEX IF NOT EXISTS idx_collaborators_email ON public.collaborators(email);
CREATE INDEX IF NOT EXISTS idx_profiles_email ON public.profiles(email);

-- Trigger para updated_at
CREATE OR REPLACE FUNCTION public.set_updated_at()
RETURNS trigger AS $$
BEGIN
  new.updated_at = now();
  RETURN new;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_profiles_set_updated ON public.profiles;
CREATE TRIGGER trg_profiles_set_updated
BEFORE UPDATE ON public.profiles
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

DROP TRIGGER IF EXISTS trg_collaborators_touch_updated ON public.collaborators;
CREATE TRIGGER trg_collaborators_touch_updated
BEFORE UPDATE ON public.collaborators
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

-- --------------------------------------------------------------
-- 4. CONFIGURACIÓN DEL NEGOCIO
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.business CASCADE;
CREATE TABLE public.business (
  id integer primary key default 1,
  business_name text,
  address text,
  phone text,
  email text,
  rnc text CHECK (rnc ~ '^[0-9]{9,11}$' OR rnc IS NULL),
  quotation_rates jsonb,
  owner_user_id uuid references public.profiles(id) on delete set null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

COMMENT ON TABLE public.business IS 'Configuración general del negocio.';

CREATE INDEX IF NOT EXISTS idx_business_owner ON public.business(owner_user_id);
CREATE INDEX IF NOT EXISTS idx_business_rnc ON public.business(rnc);

-- Trigger updated_at
CREATE OR REPLACE FUNCTION public.touch_updated_at()
RETURNS trigger AS $$
BEGIN
  new.updated_at = now();
  RETURN new;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_business_touch_updated ON public.business;
CREATE TRIGGER trg_business_touch_updated
BEFORE UPDATE ON public.business
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

-- Seed inicial
INSERT INTO public.business (id, business_name, address, phone, email)
VALUES (1, 'Mi Negocio', '', '', '')
ON CONFLICT (id) DO NOTHING;

-- --------------------------------------------------------------
-- 4.b COMPATIBILIDAD: business_settings (para proyectos antiguos)
-- --------------------------------------------------------------
DROP TABLE IF EXISTS public.business_settings CASCADE;
CREATE TABLE public.business_settings (
  id integer primary key default 1,
  business_name text,
  address text,
  phone text,
  email text,
  rnc text,
  quotation_rates jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

COMMENT ON TABLE public.business_settings IS 'Tabla de compatibilidad para configuraciones del negocio; preferir public.business.';

-- Trigger updated_at (reutiliza la función touch_updated_at)
DROP TRIGGER IF EXISTS trg_business_settings_touch_updated ON public.business_settings;
CREATE TRIGGER trg_business_settings_touch_updated
BEFORE UPDATE ON public.business_settings
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

-- Consistencia de RNC
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'business_settings_rnc_check'
  ) THEN
    ALTER TABLE public.business_settings
      ADD CONSTRAINT business_settings_rnc_check
      CHECK (rnc ~ '^[0-9]{9,11}$' OR rnc IS NULL);
  END IF;
END $$;

-- Seed inicial de compatibilidad
INSERT INTO public.business_settings (id, business_name, address, phone, email)
VALUES (1, 'Mi Negocio', '', '', '')
ON CONFLICT (id) DO NOTHING;

-- --------------------------------------------------------------
-- 5.a FUNCIONES DE ROL (helpers)
-- --------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.is_owner(uid uuid)
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS(
    SELECT 1 FROM public.business b WHERE b.owner_user_id = uid
  );
$$;

CREATE OR REPLACE FUNCTION public.is_admin(uid uuid)
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS(
    SELECT 1 FROM public.collaborators c
    WHERE c.id = uid AND lower(coalesce(c.role, 'colaborador')) = 'administrador'
  );
$$;

-- --------------------------------------------------------------
-- 5. ÓRDENES Y NOTIFICACIONES
-- --------------------------------------------------------------
-- Ya no necesitamos la secuencia para los IDs aleatorios
DROP SEQUENCE IF EXISTS public.orders_short_id_seq;

CREATE OR REPLACE FUNCTION public.generate_order_short_id()
RETURNS TEXT AS $$
DECLARE
    fecha_actual TEXT;
    codigo_aleatorio TEXT;
BEGIN
    -- Formato: ORD-YYYYMMDD-RANDOM
    fecha_actual := to_char(current_date, 'YYYYMMDD');
    codigo_aleatorio := upper(substring(md5(random()::text) from 1 for 6));
    RETURN 'ORD-' || fecha_actual || '-' || codigo_aleatorio;
END;
$$ LANGUAGE plpgsql;

DROP TABLE IF EXISTS public.orders CASCADE;
CREATE TABLE public.orders (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    short_id TEXT UNIQUE DEFAULT public.generate_order_short_id(),
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    client_id UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    name TEXT NOT NULL,
    phone TEXT NOT NULL,
    email TEXT,
    rnc TEXT,
    empresa TEXT,
    service_id BIGINT REFERENCES public.services(id) ON DELETE SET NULL,
    vehicle_id BIGINT REFERENCES public.vehicles(id) ON DELETE SET NULL,
    service_questions JSONB,
    pickup TEXT,
    delivery TEXT,
    origin_coords JSONB,
    destination_coords JSONB,
    "date" DATE,
    "time" TIME,
    status TEXT DEFAULT 'Pendiente' NOT NULL,
    last_collab_status TEXT, -- Nuevo campo para el estado detallado del colaborador
    assigned_to UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    assigned_at TIMESTAMPTZ,
    completed_at TIMESTAMPTZ,
    completed_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    evidence_photos JSONB,
    rating INT,
    rating_comment TEXT,
    estimated_price TEXT DEFAULT 'Por confirmar',
    monto_cobrado NUMERIC,
    metodo_pago TEXT,
    tracking_data JSONB,
    tracking_url TEXT,
    updated_at timestamptz not null default now()
);

CREATE INDEX IF NOT EXISTS idx_orders_status ON public.orders(status);
CREATE INDEX IF NOT EXISTS idx_orders_date ON public.orders("date");
CREATE INDEX IF NOT EXISTS idx_orders_assigned_to ON public.orders(assigned_to);
CREATE INDEX IF NOT EXISTS idx_orders_client_id ON public.orders(client_id);

-- Constraint de estado permitido
DO $$ BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'orders_status_check'
  ) THEN
    ALTER TABLE public.orders
      ADD CONSTRAINT orders_status_check
      CHECK (status IN ('Pendiente','Aceptada','En curso','Completada','Cancelada'));
  END IF;
END $$;

-- Trigger: setear tracking_url automáticamente al crear la orden
CREATE OR REPLACE FUNCTION public.set_order_tracking_url()
RETURNS trigger AS $$
BEGIN
  IF new.tracking_url IS NULL OR new.tracking_url = '' THEN
    new.tracking_url := '/seguimiento.html?order=' || coalesce(new.short_id::text, new.id::text);
  END IF;
  RETURN new;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_orders_set_tracking ON public.orders;
CREATE TRIGGER trg_orders_set_tracking
BEFORE INSERT ON public.orders
FOR EACH ROW EXECUTE FUNCTION public.set_order_tracking_url();

-- Trigger updated_at para orders
DROP TRIGGER IF EXISTS trg_orders_touch_updated ON public.orders;
CREATE TRIGGER trg_orders_touch_updated
BEFORE UPDATE ON public.orders
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

-- Notificaciones
DROP TABLE IF EXISTS public.notifications CASCADE;
CREATE TABLE public.notifications (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade,
  title text,
  body text,
  data jsonb,
  created_at timestamptz not null default now(),
  read_at timestamptz
);
CREATE INDEX IF NOT EXISTS idx_notifications_user ON public.notifications(user_id);

-- Suscripciones push
DROP TABLE IF EXISTS public.push_subscriptions CASCADE;
CREATE TABLE public.push_subscriptions (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id) on delete cascade,
  endpoint text not null,
  keys jsonb not null,
  created_at timestamptz not null default now()
);
CREATE INDEX IF NOT EXISTS idx_push_subscriptions_user ON public.push_subscriptions(user_id);

-- --------------------------------------------------------------
-- 6. POLÍTICAS RLS (SEGURIDAD)
-- --------------------------------------------------------------
ALTER TABLE public.vehicles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.services ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.collaborators ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.matriculas ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.business ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.business_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.push_subscriptions ENABLE ROW LEVEL SECURITY;

-- Limpieza previa de políticas antiguas
DROP POLICY IF EXISTS "public_read_vehicles" ON public.vehicles;
DROP POLICY IF EXISTS "public_read_services" ON public.services;
DROP POLICY IF EXISTS "owner_all_access_vehicles" ON public.vehicles;
DROP POLICY IF EXISTS "owner_all_access_services" ON public.services;
DROP POLICY IF EXISTS "public_read_profiles" ON public.profiles;
DROP POLICY IF EXISTS "users_update_own_profile" ON public.profiles;
DROP POLICY IF EXISTS "public_insert_pending_orders" ON public.orders;
DROP POLICY IF EXISTS "clients_read_own_orders" ON public.orders;
DROP POLICY IF EXISTS "collaborator_read_pending_orders" ON public.orders;
DROP POLICY IF EXISTS "collaborator_read_assigned_orders" ON public.orders;
DROP POLICY IF EXISTS "collaborator_update_own_orders" ON public.orders;
DROP POLICY IF EXISTS "owner_admin_all_orders" ON public.orders;
DROP POLICY IF EXISTS "collaborator_self_select" ON public.collaborators;
DROP POLICY IF EXISTS "collaborator_self_update" ON public.collaborators;
DROP POLICY IF EXISTS "owner_manage_collaborators" ON public.collaborators;
DROP POLICY IF EXISTS "admin_manage_collaborators" ON public.collaborators;
DROP POLICY IF EXISTS "collaborator_read_own_matriculas" ON public.matriculas;
DROP POLICY IF EXISTS "owner_manage_matriculas" ON public.matriculas;
DROP POLICY IF EXISTS "admin_manage_matriculas" ON public.matriculas;
DROP POLICY IF EXISTS "owner_full_access_business" ON public.business;
DROP POLICY IF EXISTS "owner_full_access_business_settings" ON public.business_settings;
DROP POLICY IF EXISTS "user_manage_own_push_subscriptions" ON public.push_subscriptions;
DROP POLICY IF EXISTS "user_read_own_notifications" ON public.notifications;
DROP POLICY IF EXISTS "user_manage_own_notifications" ON public.notifications;

-- Vehículos y servicios
CREATE POLICY "public_read_vehicles" ON public.vehicles FOR SELECT USING (true);
CREATE POLICY "public_read_services" ON public.services FOR SELECT USING (true);
CREATE POLICY "public_read_services_name" ON public.services FOR SELECT USING (true);
CREATE POLICY "owner_all_access_vehicles" ON public.vehicles FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);
CREATE POLICY "owner_all_access_services" ON public.services FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Profiles
CREATE POLICY "public_read_profiles" ON public.profiles FOR SELECT USING (true);
CREATE POLICY "users_update_own_profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Permitir lectura pública de perfiles de colaboradores que completaron órdenes
CREATE POLICY "public_read_completed_by_profiles" ON public.profiles FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM public.orders o
    WHERE o.completed_by = profiles.id AND o.status IN ('Completada', 'Cancelada')
  )
);

-- Orders
-- Importante para evitar el error RLS en INSERT desde cliente anónimo o autenticado sin client_id
-- Permitimos insertar órdenes en estado Pendiente, asignando client_id NULL o igual a auth.uid()
CREATE POLICY "public_insert_pending_orders" ON public.orders
FOR INSERT
WITH CHECK (
  status = 'Pendiente' AND (client_id IS NULL OR client_id = auth.uid())
);

CREATE POLICY "clients_read_own_orders" ON public.orders FOR SELECT USING (client_id = auth.uid());
CREATE POLICY "collaborator_read_pending_orders" ON public.orders FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM public.collaborators c
    WHERE c.id = auth.uid() AND c.status = 'activo'
  ) AND status = 'Pendiente'
);
CREATE POLICY "collaborator_read_assigned_orders" ON public.orders FOR SELECT USING (assigned_to = auth.uid());
CREATE POLICY "collaborator_update_own_orders" ON public.orders FOR UPDATE USING (assigned_to = auth.uid());
CREATE POLICY "owner_admin_all_orders" ON public.orders FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Permitir lectura pública de órdenes completadas y canceladas (historial)
CREATE POLICY "public_read_completed_orders" ON public.orders FOR SELECT USING (
  status IN ('Completada', 'Cancelada')
);

-- Collaborators y Matrículas
CREATE POLICY "collaborator_self_select" ON public.collaborators FOR SELECT USING (auth.uid() = id);
CREATE POLICY "collaborator_self_update" ON public.collaborators FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "owner_manage_collaborators" ON public.collaborators FOR ALL USING (
  public.is_owner(auth.uid())
);
CREATE POLICY "admin_manage_collaborators" ON public.collaborators FOR ALL USING (
  public.is_admin(auth.uid())
);

CREATE POLICY "collaborator_read_own_matriculas" ON public.matriculas FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "owner_manage_matriculas" ON public.matriculas FOR ALL USING (
  public.is_owner(auth.uid())
);
CREATE POLICY "admin_manage_matriculas" ON public.matriculas FOR ALL USING (
  public.is_admin(auth.uid())
);

-- Business
CREATE POLICY "owner_full_access_business" ON public.business
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Business Settings (compatibilidad)
CREATE POLICY "owner_full_access_business_settings" ON public.business_settings
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Push Subscriptions
CREATE POLICY "user_manage_own_push_subscriptions" ON public.push_subscriptions
FOR ALL USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

-- Notifications
CREATE POLICY "user_manage_own_notifications" ON public.notifications
FOR ALL USING (user_id = auth.uid()) WITH CHECK (user_id = auth.uid());

-- --------------------------------------------------------------
-- 7. SEED DE CATÁLOGOS
-- --------------------------------------------------------------
INSERT INTO public.vehicles (name, description, image_url, is_active) VALUES
('Camión Pequeño', '14 pies', 'https://i.postimg.cc/DynCkfnV/camionpequeno.jpg', true),
('Furgoneta', 'Ideal para paquetería y cargas ligeras', 'https://i.postimg.cc/RV4P5C9f/furgoneta.jpg', true),
('Grúa Vehicular', 'Para remolque de autos y jeepetas', 'https://i.postimg.cc/hvgBTFmy/grua-vehiculos.jpg', true),
('Camión Grande', '22 a 28 pies', 'https://i.postimg.cc/44z8SHCc/camiongrande.jpg', true),
('Grúa de Carga', 'Para izado y movimiento de carga', 'https://i.postimg.cc/0yHZwpSf/grua.png', true),
('Motor', 'Para paquetería y entregas rápidas', 'https://i.postimg.cc/JMNgTvmd/motor.jpg', true),
('Camión Abierto', 'Carga y transporte de materiales y mineros', 'https://i.postimg.cc/Kvx9ScFT/camionminero.jpg', true)
ON CONFLICT (name) DO NOTHING;

INSERT INTO public.services (name, description, image_url, is_active, display_order) VALUES
('Transporte Comercial', 'Transporte seguro de mercancías comerciales.', 'https://i.postimg.cc/sXCdCFTD/transporte-comercial.png', true, 1),
('Paquetería', 'Envíos de paquetes seguros y rápidos.', 'https://i.postimg.cc/zBYZYmx8/paqueteria.png', true, 2),
('Carga Pesada', 'Especialistas en transporte de carga pesada.', 'https://i.postimg.cc/B65b1fbv/pesado.jpg', true, 3),
('Flete', 'Servicios de flete a nivel nacional.', 'https://i.postimg.cc/15vQnj3w/flete.png', true, 4),
('Mudanza', 'Mudanza residencial y comercial.', 'https://i.postimg.cc/HszyJd5m/mudanza.jpg', true, 5),
('Grúa Vehículo', 'Remolque de vehículos.', 'https://i.postimg.cc/hvgBTFmy/grua-vehiculos.jpg', true, 6),
('Botes Mineros', 'Alquiler y transporte de botes.', 'https://i.postimg.cc/gzL29mkt/botes-minenos.png', true, 7),
('Grúa de Carga', 'Movimiento de carga pesada.', 'https://i.postimg.cc/sDjz2rsx/grua-carga.png', true, 8)
ON CONFLICT (name) DO NOTHING;

-- --------------------------------------------------------------
-- 8. FACTURACIÓN: INVOICES, ITEMS, PAYMENTS Y ADJUNTOS
-- --------------------------------------------------------------

-- Secuencia y función para números de factura
DROP SEQUENCE IF EXISTS public.invoices_number_seq;
CREATE SEQUENCE public.invoices_number_seq START WITH 1;

CREATE OR REPLACE FUNCTION public.generate_invoice_number()
RETURNS TEXT AS $$
DECLARE
    next_id BIGINT;
BEGIN
    next_id := nextval('public.invoices_number_seq');
    RETURN 'INV-' || lpad(next_id::TEXT, 6, '0');
END;
$$ LANGUAGE plpgsql;

-- Tabla de facturas
DROP TABLE IF EXISTS public.invoices CASCADE;
CREATE TABLE public.invoices (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  invoice_number text unique default public.generate_invoice_number(),
  client_id uuid references public.profiles(id) on delete set null,
  order_id bigint references public.orders(id) on delete set null,
  currency text default 'DOP' not null,
  status text default 'draft' not null CHECK (status IN ('draft','issued','paid','cancelled')),
  due_date date,
  issued_by uuid references public.profiles(id) on delete set null,
  subtotal numeric(12,2) default 0,
  tax numeric(12,2) default 0,
  total numeric(12,2) default 0,
  notes text
);

CREATE INDEX IF NOT EXISTS idx_invoices_client ON public.invoices(client_id);
CREATE INDEX IF NOT EXISTS idx_invoices_order ON public.invoices(order_id);
CREATE INDEX IF NOT EXISTS idx_invoices_status ON public.invoices(status);

-- Items de factura
DROP TABLE IF EXISTS public.invoice_items CASCADE;
CREATE TABLE public.invoice_items (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  invoice_id bigint not null references public.invoices(id) on delete cascade,
  description text not null,
  quantity numeric(12,2) not null default 1,
  unit_price numeric(12,2) not null default 0,
  amount numeric(12,2) not null default 0
);

CREATE INDEX IF NOT EXISTS idx_invoice_items_invoice ON public.invoice_items(invoice_id);

-- Trigger para calcular amount
CREATE OR REPLACE FUNCTION public.invoice_items_compute_amount()
RETURNS trigger AS $$
BEGIN
  NEW.amount := COALESCE(NEW.quantity,0) * COALESCE(NEW.unit_price,0);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_invoice_items_compute_amount ON public.invoice_items;
CREATE TRIGGER trg_invoice_items_compute_amount
BEFORE INSERT OR UPDATE ON public.invoice_items
FOR EACH ROW EXECUTE FUNCTION public.invoice_items_compute_amount();

-- Pagos
DROP TABLE IF EXISTS public.payments CASCADE;
CREATE TABLE public.payments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  invoice_id bigint not null references public.invoices(id) on delete cascade,
  payer_id uuid references public.profiles(id) on delete set null,
  amount numeric(12,2) not null,
  method text,
  reference text,
  status text default 'pending' not null CHECK (status IN ('pending','confirmed','failed','refunded')),
  paid_at timestamptz,
  notes text
);

CREATE INDEX IF NOT EXISTS idx_payments_invoice ON public.payments(invoice_id);
CREATE INDEX IF NOT EXISTS idx_payments_payer ON public.payments(payer_id);
CREATE INDEX IF NOT EXISTS idx_payments_status ON public.payments(status);

-- Métodos de pago (catálogo sencillo)
DROP TABLE IF EXISTS public.payment_methods CASCADE;
CREATE TABLE public.payment_methods (
  id integer generated by default as identity primary key,
  created_at timestamptz not null default now(),
  code text unique not null,
  name text not null,
  is_active boolean not null default true
);

-- Adjuntos/recibos de pago
DROP TABLE IF EXISTS public.payment_receipts CASCADE;
CREATE TABLE public.payment_receipts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  uploaded_at timestamptz not null default now(),
  payment_id bigint not null references public.payments(id) on delete cascade,
  file_url text not null
);

CREATE INDEX IF NOT EXISTS idx_payment_receipts_payment ON public.payment_receipts(payment_id);

-- Historial de estado de factura
DROP TABLE IF EXISTS public.invoice_status_history CASCADE;
CREATE TABLE public.invoice_status_history (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  changed_at timestamptz not null default now(),
  invoice_id bigint not null references public.invoices(id) on delete cascade,
  old_status text,
  new_status text,
  changed_by uuid references public.profiles(id) on delete set null
);

CREATE INDEX IF NOT EXISTS idx_invoice_history_invoice ON public.invoice_status_history(invoice_id);

-- Triggers updated_at reutilizando touch_updated_at
DROP TRIGGER IF EXISTS trg_invoices_touch_updated ON public.invoices;
CREATE TRIGGER trg_invoices_touch_updated
BEFORE UPDATE ON public.invoices
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

DROP TRIGGER IF EXISTS trg_invoice_items_touch_updated ON public.invoice_items;
CREATE TRIGGER trg_invoice_items_touch_updated
BEFORE UPDATE ON public.invoice_items
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

DROP TRIGGER IF EXISTS trg_payments_touch_updated ON public.payments;
CREATE TRIGGER trg_payments_touch_updated
BEFORE UPDATE ON public.payments
FOR EACH ROW EXECUTE FUNCTION public.touch_updated_at();

-- Registro automático de cambios de estado de factura
CREATE OR REPLACE FUNCTION public.log_invoice_status_change()
RETURNS trigger AS $$
BEGIN
  IF NEW.status IS DISTINCT FROM OLD.status THEN
    INSERT INTO public.invoice_status_history(invoice_id, old_status, new_status, changed_by)
    VALUES (OLD.id, OLD.status, NEW.status, auth.uid());
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_invoices_log_status ON public.invoices;
CREATE TRIGGER trg_invoices_log_status
BEFORE UPDATE OF status ON public.invoices
FOR EACH ROW EXECUTE FUNCTION public.log_invoice_status_change();

-- RLS para nuevas tablas
ALTER TABLE public.invoices ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.invoice_items ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payment_methods ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.payment_receipts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.invoice_status_history ENABLE ROW LEVEL SECURITY;

-- Limpieza por si existían políticas previas
DROP POLICY IF EXISTS "clients_read_own_invoices" ON public.invoices;
DROP POLICY IF EXISTS "owner_admin_all_invoices" ON public.invoices;
DROP POLICY IF EXISTS "items_follow_invoice_access" ON public.invoice_items;
DROP POLICY IF EXISTS "owner_admin_all_invoice_items" ON public.invoice_items;
DROP POLICY IF EXISTS "clients_manage_own_payments" ON public.payments;
DROP POLICY IF EXISTS "owner_admin_all_payments" ON public.payments;
DROP POLICY IF EXISTS "public_read_payment_methods" ON public.payment_methods;
DROP POLICY IF EXISTS "owner_admin_manage_payment_methods" ON public.payment_methods;
DROP POLICY IF EXISTS "receipts_follow_payment_access" ON public.payment_receipts;
DROP POLICY IF EXISTS "owner_admin_all_receipts" ON public.payment_receipts;
DROP POLICY IF EXISTS "history_follow_invoice_access" ON public.invoice_status_history;
DROP POLICY IF EXISTS "owner_admin_all_history" ON public.invoice_status_history;

-- Políticas: Invoices
CREATE POLICY "clients_read_own_invoices" ON public.invoices
FOR SELECT USING (
  client_id = auth.uid()
);

CREATE POLICY "owner_admin_all_invoices" ON public.invoices
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Políticas: Items siguen acceso de su factura
CREATE POLICY "items_follow_invoice_access" ON public.invoice_items
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM public.invoices i
    WHERE i.id = invoice_id AND i.client_id = auth.uid()
  )
);

CREATE POLICY "owner_admin_all_invoice_items" ON public.invoice_items
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Políticas: Payments (clientes pueden registrar pagos de sus facturas)
CREATE POLICY "clients_manage_own_payments" ON public.payments
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM public.invoices i
    WHERE i.id = invoice_id AND (i.client_id = auth.uid())
  ) OR payer_id = auth.uid()
) WITH CHECK (
  payer_id = auth.uid() AND EXISTS (
    SELECT 1 FROM public.invoices i
    WHERE i.id = invoice_id AND i.client_id = auth.uid()
  )
);

CREATE POLICY "owner_admin_all_payments" ON public.payments
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Políticas: Métodos de pago
CREATE POLICY "public_read_payment_methods" ON public.payment_methods
FOR SELECT USING (true);

CREATE POLICY "owner_admin_manage_payment_methods" ON public.payment_methods
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Políticas: Recibos de pago (siguen el acceso del pago y factura)
CREATE POLICY "receipts_follow_payment_access" ON public.payment_receipts
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM public.payments p
    JOIN public.invoices i ON i.id = p.invoice_id
    WHERE p.id = payment_id AND (i.client_id = auth.uid() OR p.payer_id = auth.uid())
  )
) WITH CHECK (
  EXISTS (
    SELECT 1 FROM public.payments p
    JOIN public.invoices i ON i.id = p.invoice_id
    WHERE p.id = payment_id AND (i.client_id = auth.uid() OR p.payer_id = auth.uid())
  )
);

CREATE POLICY "owner_admin_all_receipts" ON public.payment_receipts
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- Políticas: Historial de factura
CREATE POLICY "history_follow_invoice_access" ON public.invoice_status_history
FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM public.invoices i
    WHERE i.id = invoice_id AND i.client_id = auth.uid()
  )
);

CREATE POLICY "owner_admin_all_history" ON public.invoice_status_history
FOR ALL USING (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
) WITH CHECK (
  public.is_owner(auth.uid()) OR public.is_admin(auth.uid())
);

-- =============================================================
--                      FIN DEL ESQUEMA
-- =============================================================

-- Admin/owner opcional (requiere existir en auth.users para no romper FK)
INSERT INTO public.profiles (id, full_name, email, phone, created_at, updated_at)
SELECT
  'a1bd79f0-8a12-40e3-8ee5-d24427dddf71',
  'Carlos López',
  'carloslopez@gmail.com',
  '8090000000',
  NOW(),
  NOW()
WHERE EXISTS (SELECT 1 FROM auth.users WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71')
  AND NOT EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71');

INSERT INTO public.collaborators (id, name, email, phone, matricula, status, created_at)
SELECT
  'a1bd79f0-8a12-40e3-8ee5-d24427dddf71',
  'Carlos López',
  'carloslopez@gmail.com',
  '8090000000',
  '1338547',
  'activo',
  NOW()
WHERE EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71')
  AND NOT EXISTS (SELECT 1 FROM public.collaborators WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71');

UPDATE public.collaborators
SET role = 'administrador'
WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71';

INSERT INTO public.matriculas (user_id, matricula, status, created_at)
SELECT
  'a1bd79f0-8a12-40e3-8ee5-d24427dddf71',
  '1338547',
  'activo',
  NOW()
WHERE EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71')
  AND NOT EXISTS (
    SELECT 1 FROM public.matriculas WHERE user_id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71'
  );

UPDATE public.business
SET owner_user_id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71'
WHERE id = 1
  AND EXISTS (SELECT 1 FROM public.profiles WHERE id = 'a1bd79f0-8a12-40e3-8ee5-d24427dddf71');
